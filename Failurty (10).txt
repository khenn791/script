-- i hate girls bc all cheating
-- skid if you want.
-- i'm quit


game.StarterGui:SetCore("SendNotification",{Title="loading",Text="wait",Duration=5})


loadstring(game:HttpGet("https://raw.githubusercontent.com/khenn791/script-khen/refs/heads/main/larplarpbypasser.txt"))()

loadstring(game:HttpGet("https://raw.githubusercontent.com/aa8283/i/refs/heads/main/Protected_2547730226887233.txt"))()
-----

getgenv().venus = {
    ["Enabled"] = false,
    ["AimPart"] = "Head",
    ["Prediction"] = 0.12588,
    ["Smoothness"] = 1,
    ["ShakeValue"] = 0,
    ["AutoPred"] = false,
    ["Loaded"] = false,
    ["Mode"] = "Controller",
    ["AutoAirEnabled"] = false,
    ["AntiGroundShots"] = {
        ["enabled"] = false,
        ["value"] = 0.5,
    },
    ["cframe"] = {
        ["enabled"] = false,
        ["speed"] = 2,
        ["TargetStrafe"] = {
            ["Enabled"] = false,
            ["StrafeSpeed"] = 10,
            ["StrafeRadius"] = 7,
            ["StrafeHeight"] = 3,
            ["RandomizerMode"] = true
        }
    }
}

getgenv().Fov = {
    ["FOVSize"] = 90,
    ["FOVColor"] = Color3.fromRGB(255, 0, 0),
    ["FOVVisible"] = true,
    ["FOVShape"] = "Circle"
}

getgenv().targetaim = {
    ["enabled"] = false,
    ["targetPart"] = "UpperTorso",
    ["prediction"] = 0.12588
}

getgenv().desync = {
    ["sky"] = false,
    ["invis"] = false,
    ["jump"] = false,
    ["network"] = false
}

getgenv().Misc = {
    ["LowGfx"] = false,
}

getgenv().FPSunlocker = {
    ["Enabled"] = true,
    ["FPSCap"] = 9999
}

getgenv().Triggerbot = {
    ["ClosestPart"] = {
        ["HitParts"] = {"Head", "UpperTorso", "LowerTorso", "HumanoidRootPart", "RightFoot", "LeftFoot"}
    },
    ["FOV"] = {
        ["Enabled"] = true,
        ["Size"] = 13,
        ["Centered FOV"] = true,
        ["Visible"] = false,
        ["Filled"] = false,
        ["Color"] = Color3.fromRGB(255, 0, 0)
    },
    ["Settings"] = {
        ["Prediction"] = 0.111,
        ["Click Delay"] = 0.1,
        ["Activation Delay"] = 2,
        ["IgnoreFriends"] = false,
        ["Automatically Fire"] = false,
    }
}

local InnalillahiMataKiri = Instance.new("ScreenGui")
InnalillahiMataKiri.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
InnalillahiMataKiri.Parent = game:GetService("CoreGui") -- Ensures the GUI is parented to CoreGui

local Notifications_Frame = Instance.new("Frame")
Notifications_Frame.Name = "Notifications"
Notifications_Frame.BackgroundTransparency = 1
Notifications_Frame.Size = UDim2.new(1, 0, 1, 36)
Notifications_Frame.Position = UDim2.fromOffset(0, -36)
Notifications_Frame.ZIndex = 5
Notifications_Frame.Parent = InnalillahiMataKiri

local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local NotificationSystem = {}
local ActiveNotifications = {}

local function GetDictionaryLength(dictionary)
    local count = 0
    for _ in pairs(dictionary) do
        count += 1
    end
    return count
end

function NotificationSystem:Notify(Content: string, Delay: number)
    assert(typeof(Content) == "string", "missing argument #1, (string expected got " .. typeof(Content) .. ")")
    local Delay = typeof(Delay) == "number" and Delay or 3

    local Text = Instance.new("TextLabel")
    local Notification = {
        self = Text,
        Class = "Notification"
    }

    Text.Name = "Notification"
    Text.BackgroundTransparency = 1
    -- Position kept on the left, slightly moved down (-130 instead of -150)
    Text.Position = UDim2.new(0.5, -190, 1, -130 - (GetDictionaryLength(ActiveNotifications) * 15)) -- Left side, slightly down
    Text.Size = UDim2.new(0, 200, 0, 15) -- Reduced height from 20 to 15
    Text.Text = Content
    Text.Font = Enum.Font.SourceSans
    Text.TextSize = 14 -- Reduced text size from 17 to 14
    Text.TextColor3 = Color3.new(1, 1, 1)
    Text.TextStrokeTransparency = 0.2
    Text.TextTransparency = 1
    Text.RichText = true
    Text.ZIndex = 4
    Text.Parent = Notifications_Frame

    local function CustomTweenOffset(Offset: number)
        spawn(function()
            local Steps = 33
            for i = 1, Steps do
                Text.Position += UDim2.fromOffset(Offset / Steps, 0)
                RunService.RenderStepped:Wait()
            end
        end)
    end

    function Notification:Destroy()
        ActiveNotifications[Notification] = nil
        Text:Destroy()

        for _, v in pairs(ActiveNotifications) do
            v.self.Position += UDim2.fromOffset(0, 15) -- Spacing adjusted for smaller text
        end
    end

    ActiveNotifications[Notification] = Notification

    local TweenIn = TweenService:Create(Text, TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0), { TextTransparency = 0 })
    local TweenOut = TweenService:Create(Text, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, 0, false, 0), { TextTransparency = 1 })

    TweenIn:Play()
    CustomTweenOffset(100)

    TweenIn.Completed:Connect(function()
        delay(Delay, function()
            TweenOut:Play()
            CustomTweenOffset(100)

            TweenOut.Completed:Connect(function()
                Notification:Destroy()
            end)
        end)
    end)
end

repeat wait() until game:IsLoaded()



local repo = 'https://raw.githubusercontent.com/khen791/library/cac/'


local Library = loadstring(game:HttpGet(repo .. 'main.txt'))()

local ThemeManager = loadstring(game:HttpGet(repo .. 'nini/ThemeManager.lua'))()

local SaveManager = loadstring(game:HttpGet(repo .. 'nini/SaveManager.lua'))()


Library:Notify('khen.cc')
wait(0.5)


local Ui22 = Instance.new("ScreenGui")
Ui22.Name = "Ui22"
Ui22.Parent = game.CoreGui
Ui22.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
Ui22.ResetOnSpawn = false

-- Nút Show/Hide UI
local Image3 = Instance.new("TextButton")
Image3.Name = "Image3"
Image3.Parent = Ui22
Image3.Active = true
Image3.Draggable = true
Image3.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- màu nền dịu
Image3.BackgroundTransparency = 0.3
Image3.Size = UDim2.new(0, 100, 0, 50)
Image3.Position = UDim2.new(1, -150, 0, 20) -- lệch trái một chút
Image3.Text = "Show UI"
Image3.TextColor3 = Color3.fromRGB(200, 200, 200) -- chữ xám nhạt
Image3.TextScaled = false
Image3.TextSize = 16
Image3.Font = Enum.Font.Gotham
Image3.BorderSizePixel = 0

-- Bo góc
local Ui2corner = Instance.new("UICorner")
Ui2corner.CornerRadius = UDim.new(0, 15)
Ui2corner.Parent = Image3

-- Viền trắng nhẹ
local UIStroke = Instance.new("UIStroke")
UIStroke.Color = Color3.fromRGB(255, 255, 255)
UIStroke.Thickness = 2
UIStroke.Parent = Image3

-- Hiệu ứng hover
Image3.MouseEnter:Connect(function()
    Image3.BackgroundTransparency = 0.1
    UIStroke.Color = Color3.fromRGB(200, 200, 200)
    Image3.TextColor3 = Color3.fromRGB(255, 255, 255) -- sáng hơn khi hover
end)

Image3.MouseLeave:Connect(function()
    Image3.BackgroundTransparency = 0.3
    UIStroke.Color = Color3.fromRGB(255, 255, 255)
    Image3.TextColor3 = Color3.fromRGB(200, 200, 200) -- quay lại xám nhạt
end)

-- Khi bấm nút
Image3.MouseButton1Click:Connect(function()
    Open = not Open
    Library:Toggle(Open)

    if Open then
        Image3.Text = "Hide UI"
        Image3.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    else
        Image3.Text = "Show UI"
        Image3.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    end
end)




local Window = Library:CreateWindow({
    Title = "Failurty.cc [khen.cc]",
    Center = true,
    AutoShow = true,
    Size = UDim2.new(0, 450, 0, 380)
})

local Tabs = {
        Main = Window:AddTab("Main"),
        Rage = Window:AddTab("Visuals"),
        More = Window:AddTab("Buttons"),
        ["UI Settings"] = Window:AddTab("Configs"),
        Credit = Window:AddTab("Credit")
    }

Library:SetWatermarkVisibility(true)

local FrameTimer = tick()
local FrameCounter = 0
local Ping = 0

local WatermarkConnection = game:GetService('RunService').RenderStepped:Connect(function()
    Ping = math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())

    Library:SetWatermark(('imkhen | %d ms'):format(Ping))
end)

Library:OnUnload(function()
    WatermarkConnection:Disconnect()

    print('Unloaded!')
    Library.Unloaded = true
end)

local assist = Tabs.Main:AddLeftGroupbox("Aim Assist")

local air = Tabs.Main:AddLeftGroupbox("Air Settings")

local set = Tabs.Main:AddRightGroupbox("Prediction config")

local safe = Tabs.Main:AddRightGroupbox("Safety")

local tar = Tabs.Main:AddRightGroupbox("Target Strafe")

local fov = Tabs.Main:AddLeftGroupbox("Fov")

local cframe = Tabs.More:AddRightGroupbox("Cframe")

local visuals = Tabs.Rage:AddLeftGroupbox("Visuals")

local esp = Tabs.Rage:AddLeftGroupbox("Esp")

local anti = Tabs.Rage:AddRightGroupbox("Desync")

local net = Tabs.Rage:AddRightGroupbox("Fast Flags")

local ant = Tabs.Rage:AddRightGroupbox("Anti Lock")

local walkspeed = Tabs.More:AddLeftGroupbox("Walk Speed")

assist:AddToggle(
    "Enable Camlock",
    {
        Text = "Enable Aim assist",
        Default = false,
        Tooltip = "Enable",
        Callback = function(state)
            venus.Enabled = state
        end
    }
)

safe:AddToggle(
    "Enable AntiGroundShots",
    {
        Text = "Antigroundshots",
        Default = false,
        Tooltip = "Enable for safety",
        Callback = function(state)
            venus.AntiGroundShots.enabled = state
        end
    }
) 

safe:AddInput(
        "Value",
        {
            Default = "0.5",
            Numeric = true,
            Finished = false,
            Text = "Value",
            Tooltip = "Change if you would like to",
            Placeholder = "0.5",
            Callback = function(value)
                venus.AntiGroundShots.value = value
            end
        }
    )

set:AddToggle(
    "Enable AutoPrediction",
    {
        Text = "Enable AutoPrediction",
        Default = false,
        Tooltip = "Enable",
        Callback = function(state)
            venus.AutoPred = state
            venus.CamlockEnabled = state -- Enable auto prediction for camlock
            venus.TargetAimEnabled = state -- Enable auto prediction for target aim
        end
    }
)

set:AddInput(
    "Prediction",
    {
        Default = "Prediction",
        Numeric = true,
        Finished = false,
        Text = "Prediction",
        Tooltip = "Change Prediction for Target and Camlock",
        Placeholder = "0.1",
        Callback = function(value)
            venus.Prediction = tonumber(value) or 1
        end
    }
)

set:AddInput(
        "Smoothness",
        {
            Default = "Smoothness",
            Numeric = false,
            Finished = false,
            Text = "Smoothness",
            Tooltip = "Change smoothing For Target",
            Placeholder = "0.1",
            Callback = function(value)
                venus.Smoothness = value
            end
        }
    )

assist:AddToggle(
    "Enable LookAt",
    {
        Text = "Enable Look At",
        Default = false,  -- Set default to true (enabled) or false (disabled)
        Tooltip = "Enable or disable the LookAt functionality",
        Callback = function(state)
            venus.LookAtEnabled = state
        end
    }
)

tar:AddToggle(
    "Enable Target Strafe",
    {
        Text = "Target Strafe",
        Default = false,
        Tooltip = "Toggle Target Strafe (Orbiting)",
        Callback = function(state)
            venus.cframe.TargetStrafe.Enabled = state
        end
    }
)

tar:AddInput(
    "Target Strafe Distance",
    {
        Default = "15",
        Numeric = true,
        Finished = false,
        Text = "Distance",
        Tooltip = "Adjust the distance for target strafe (orbit radius)",
        Placeholder = "20",
        Callback = function(value)
            venus.cframe.TargetStrafe.StrafeRadius = tonumber(value) or venus.cframe.TargetStrafe.StrafeRadius
        end
    }
)

tar:AddInput(
    "Target Strafe Speed",
    {
        Default = "5",
        Numeric = true,
        Finished = false,
        Text = "Speed",
        Tooltip = "Adjust the speed for target strafe (orbiting)",
        Placeholder = "10",
        Callback = function(value)
            venus.cframe.TargetStrafe.StrafeSpeed = tonumber(value) or venus.cframe.TargetStrafe.StrafeSpeed
        end
    }
)

tar:AddInput(
    "Target Strafe Height",
    {
        Default = "10",
        Numeric = true,
        Finished = false,
        Text = "Height",
        Tooltip = "Adjust the height for target strafe (orbiting)",
        Placeholder = "5",
        Callback = function(value)
            venus.cframe.TargetStrafe.Height = tonumber(value) or venus.cframe.TargetStrafe.Height
        end
    }
)

set:AddDropdown(
    "Hitpart",
    {
        Values = {"Head", "UpperTorso", "HumanoidRootPart", "LowerTorso", "LeftUpperArm", "RightUpperArm", "LeftLeg", "RightLeg"},
        Default = 1,
        Multi = false,
        Text = "Hitpart",
        Tooltip = "Choose the hit part",
        Callback = function(value)
            venus.AimPart = value
            targetaim.targetPart = Value
        end
    }
)

assist:AddToggle(
    "Enable TargetAim",
    {
        Text = "Enable Target Aim",
        Default = false,
        Tooltip = "Enable",
        Callback = function(state)
            targetaim.enabled = state
        end
    }
)



local RecalculateEnabled = false
local SelectedResolver = "Recalculate Velocity"
local AimingEnabled = false
local ResolverConnection
local Recalculate = nil

local function GetMoveVelocity(Player)
    if Player and Player.Character and Player.Character:FindFirstChildOfClass("Humanoid") and Player.Character:FindFirstChild("HumanoidRootPart") then
        local PlayerHumanoid = Player.Character:FindFirstChildOfClass("Humanoid")
        local MoveVelocity = PlayerHumanoid.MoveDirection * PlayerHumanoid.WalkSpeed
        return MoveVelocity
    end
    return Vector3.new(0, 0, 0)
end

-- Function to setup Recalculate Velocity resolver
local function SetupRecalculateResolver()
    Recalculate = function(Character)
        if not Character or not Character:FindFirstChild(venus.AimPart) then
            return Vector3.new(0, 0, 0)
        end
        
        local Pos = Character[venus.AimPart].Position
        local Tick = tick()

        task.wait(0.1)

        if not Character:FindFirstChild(venus.AimPart) then
            return Vector3.new(0, 0, 0)
        end

        local NewPos = Character[venus.AimPart].Position
        local NewTick = tick()

        local Delta = (NewTick - Tick)
        if Delta == 0 then
            return Vector3.new(0, 0, 0)
        end
        
        local PositionDifference = (NewPos - Pos)
        local Velocity = PositionDifference / Delta

        targetaim.Prediction = venus.Prediction
        return Velocity
    end
end

-- Function to setup Aiming resolver
local function SetupAimingResolver()
    ResolverConnection = game:GetService("RunService").Heartbeat:Connect(function()
        pcall(function()
            for _, v in pairs(game.Players:GetChildren()) do
                if v ~= game.Players.LocalPlayer and v.Character then
                    local hrp = v.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local AimPart = v.Character:FindFirstChild(venus.AimPart) or v.Character:FindFirstChild(targetaim.targetPart)
                        if AimPart and venus.Prediction and venus.Prediction > 0 then
                            local aimVelocity = (hrp.Position - AimPart.Position) / venus.Prediction
                            hrp.Velocity = Vector3.new(aimVelocity.X, 0, aimVelocity.Z)
                            hrp.AssemblyLinearVelocity = Vector3.new(aimVelocity.X, 0, aimVelocity.Z)
                        end
                    end
                end
            end
        end)
    end)
end

-- Function to setup MoveDirection resolver
local function SetupMoveDirectionResolver()
    ResolverConnection = game:GetService("RunService").Heartbeat:Connect(function()
        pcall(function()
            for _, v in pairs(game.Players:GetChildren()) do
                if v ~= game.Players.LocalPlayer and v.Character then
                    local MoveVelocity = GetMoveVelocity(v)
                    local hrp = v.Character:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        hrp.Velocity = Vector3.new(MoveVelocity.X, 0, MoveVelocity.Z)
                        hrp.AssemblyLinearVelocity = Vector3.new(MoveVelocity.X, 0, MoveVelocity.Z)
                    end
                end
            end
        end)
    end)
end

-- Function to apply the selected resolver
local function ApplyResolver()
    -- Disconnect any existing connection
    if ResolverConnection then
        ResolverConnection:Disconnect()
        ResolverConnection = nil
    end
    
    -- Reset Recalculate function
    Recalculate = nil
    
    if not RecalculateEnabled then
        return
    end

    if SelectedResolver == "Recalculate Velocity" then
        SetupRecalculateResolver()
    elseif SelectedResolver == "Aiming" then
        SetupAimingResolver()
    elseif SelectedResolver == "MoveDirection" then
        SetupMoveDirectionResolver()
    end
end

assist:AddToggle(
    "Enable Resolver",
    {
        Text = "Resolver",
        Default = false,
        Tooltip = "Enable or disable the resolver",
        Callback = function(state)
            RecalculateEnabled = state
            AimingEnabled = state
            ApplyResolver()
        end
    }
)

assist:AddDropdown(
    "Resolver Mode",
    {
        Values = {"Recalculate Velocity", "Aiming", "MoveDirection"},
        Default = 2, -- 
        Multi = false,
        Text = "Resolver Mode",
        Tooltip = "Select the resolver mode",
        Callback = function(value)
            SelectedResolver = value
            ApplyResolver()
        end
    }
)



air:AddToggle(
    "Enable Auto Air",
    {
        Text = "Auto Air",
        Default = false,
        Tooltip = "Toggle Auto Air",
        Callback = function(state)
            venus.AutoAirEnabled = state
        end
    }
)

air:AddInput(
    "JumpOffset",
    {
        Default = "Air Offset",
        Numeric = true,
        Finished = false,
        Text = "Offset",
        Tooltip = "Change Air Offset for Target and Camlock",
        Placeholder = "0",
        Callback = function(value)
            venus.JumpOffset = tonumber(value) or 0
        end
    }
)

local cframeSpeed = 0
local cframeGui = nil
local isCFrameToggleEnabled = false
local cframeConnection = nil

-- Venus table structure
if not venus then
    venus = {}
end
if not venus.cframe then
    venus.cframe = {
        enabled = false,
        speed = 0
    }
end

local function createCFrameGUI()
    if cframeGui then
        cframeGui:Destroy()
    end

    cframeGui = Instance.new("ScreenGui")
    cframeGui.Name = "CFrameSpeedGui"
    cframeGui.Parent = game.CoreGui
    cframeGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    cframeGui.ResetOnSpawn = false

    -- Nút CFrame dịu mắt
    local button = Instance.new("TextButton")
    button.Name = "CFrameButton"
    button.Parent = cframeGui
    button.Active = true
    button.Draggable = true
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    button.BackgroundTransparency = 0.3
    button.Size = UDim2.new(0, 120, 0, 50)
    button.Position = UDim2.new(1, -150, 0, 140)
    button.Text = "CFrame OFF"
    button.TextColor3 = Color3.fromRGB(180, 220, 200) -- xanh ngọc nhạt
    button.TextScaled = false
    button.TextSize = 14
    button.Font = Enum.Font.Gotham
    button.BorderSizePixel = 0

    -- Bo góc
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 15)
    buttonCorner.Parent = button

    -- Viền xanh dịu
    local buttonStroke = Instance.new("UIStroke")
    buttonStroke.Color = Color3.fromRGB(200, 255, 200)
    buttonStroke.Thickness = 2
    buttonStroke.Parent = button

    -- CFrame functionality
    local isEnabled = false

    local function startCFrameMovement()
        if cframeConnection then
            cframeConnection:Disconnect()
        end
        
        cframeConnection = game:GetService("RunService").Stepped:Connect(function()
            if isEnabled and game.Players.LocalPlayer.Character then
                local character = game.Players.LocalPlayer.Character
                local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                local humanoid = character:FindFirstChild("Humanoid")
                
                if humanoidRootPart and humanoid then
                    if humanoid.MoveDirection.Magnitude > 0 then
                        humanoidRootPart.CFrame = humanoidRootPart.CFrame + (humanoid.MoveDirection * venus.cframe.speed)
                    end
                end
            end
        end)
    end

    local function stopCFrameMovement()
        if cframeConnection then
            cframeConnection:Disconnect()
            cframeConnection = nil
        end
    end

    local function UpdateButtonAppearance()
        if isEnabled then
            button.BackgroundColor3 = Color3.fromRGB(50, 100, 50) -- xanh lá dịu khi bật
            button.Text = "CFrame ON"
            buttonStroke.Color = Color3.fromRGB(150, 255, 150)
        else
            button.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- xám khi tắt
            button.Text = "CFrame OFF"
            buttonStroke.Color = Color3.fromRGB(200, 255, 200)
        end
    end

    -- Click toggle
    button.MouseButton1Click:Connect(function()
        isEnabled = not isEnabled
        venus.cframe.enabled = isEnabled
        
        if isEnabled then
            startCFrameMovement()
        else
            stopCFrameMovement()
        end
        
        UpdateButtonAppearance()
    end)

    -- Hover
    button.MouseEnter:Connect(function()
        button.BackgroundTransparency = 0.1
        button.TextColor3 = Color3.fromRGB(220, 255, 230) -- sáng hơn khi hover
        if isEnabled then
            buttonStroke.Color = Color3.fromRGB(180, 255, 180)
        else
            buttonStroke.Color = Color3.fromRGB(180, 240, 200)
        end
    end)

    button.MouseLeave:Connect(function()
        button.BackgroundTransparency = 0.3
        button.TextColor3 = Color3.fromRGB(180, 220, 200) -- quay về dịu
        UpdateButtonAppearance()
    end)

    -- Initial
    UpdateButtonAppearance()
end

-- Phím tăng giảm tốc
game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    if input.KeyCode == Enum.KeyCode.LeftBracket then
        venus.cframe.speed = math.max(0, venus.cframe.speed - 0.5)
        print("CFrame Speed: " .. venus.cframe.speed)
        
    elseif input.KeyCode == Enum.KeyCode.RightBracket then
        venus.cframe.speed = math.min(50, venus.cframe.speed + 0.5)
        print("CFrame Speed: " .. venus.cframe.speed)
    end
end)

-- Linoria Integration
cframe:AddToggle(
    "Enable cframe",
    {
        Text = "CFrame Speed GUI",
        Default = false,
        Tooltip = "Show/Hide",
        Callback = function(state)
            isCFrameToggleEnabled = state
            if state then
                createCFrameGUI()
            else
                if cframeGui then
                    cframeGui:Destroy()
                    cframeGui = nil
                end
                -- Stop movement when GUI is hidden
                if cframeConnection then
                    cframeConnection:Disconnect()
                    cframeConnection = nil
                end
                venus.cframe.enabled = false
            end
        end
    }
)

cframe:AddInput(
    "CFrame Speed Amount",
    {
        Default = tostring(venus.cframe.speed),
        Numeric = true,
        Finished = true,
        Text = "Amount",
        Tooltip = "Speed",
        Placeholder = "25",
        Callback = function(value)
            venus.cframe.speed = tonumber(value) or venus.cframe.speed
            cframeSpeed = venus.cframe.speed
        end
    }
)


-- Cleanup when player leaves
game.Players.LocalPlayer.AncestryChanged:Connect(function()
    if not game.Players.LocalPlayer.Parent then
        if cframeConnection then
            cframeConnection:Disconnect()
        end
        if cframeGui then
            cframeGui:Destroy()
        end
    end
end)



-- Highest Roblox velocity is 128^2 or 16384
local velMax = (128 ^ 2)

-- Time to release and choke the replication packets
local timeRelease, timeChoke = 0.015, 0.105

-- Function aliases
local Property, Wait = sethiddenproperty, wait
local Radian, Random, Ceil = math.rad, math.random, math.ceil
local Angle = CFrame.Angles
local Vector = Vector3.new
local Service = game.GetService

-- Services
local Run = Service(game, 'RunService')
local statPing = Service(game, 'Stats').PerformanceStats.Ping
local Root = Service(game, 'Players').LocalPlayer.Character:WaitForChild("HumanoidRootPart")

-- Connections
local runRen, runBeat = Run.RenderStepped, Run.Heartbeat
local runRenWait, runRenCon = runRen.Wait, runRen.Connect
local runBeatCon = runBeat.Connect

-- Ping function
local Ping = statPing.GetValue

-- Client replication choking/sleeping
local function Sleep()
    Property(Root, 'NetworkIsSleeping', true)
end

-- Initialization function
local function Init()
    local rootVel = Root.Velocity
    local rootAng = Random(-180, 180)
    local rootOffset = Vector(
        Random(-velMax, velMax),
        -Random(0, velMax),
        Random(-velMax, velMax)
    )

    Root.CFrame *= Angle(0, Radian(rootAng), 0)
    Root.Velocity = rootOffset

    runRenWait(runRen) -- Sync velocity smoothly with render
    Root.CFrame *= Angle(0, Radian(-rootAng), 0)
    Root.Velocity = rootVel
end

-- AntiGroundShot Function

local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")

local GROUND_SHOT_THRESHOLD = 5 -- Maximum distance from feet to consider a ground shot
local DETECTION_RANGE = 20 -- How far away to check for ground shots

local function isGroundShot(hitPosition)
    -- Check if shot landed near player's feet
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return false end
    
    local feetPosition = rootPart.Position - Vector3.new(0, character:FindFirstChild("Humanoid").HipHeight, 0)
    local distanceToFeet = (hitPosition - feetPosition).Magnitude
    
    return distanceToFeet <= GROUND_SHOT_THRESHOLD
end

local function onCharacterAdded(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
end

localPlayer.CharacterAdded:Connect(onCharacterAdded)

-- Listen for bullets near player
workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
    workspace.CurrentCamera.ChildAdded:Connect(function(child)
        if child:IsA("BasePart") and child.Name == "Bullet" then
            if (child.Position - character:WaitForChild("HumanoidRootPart").Position).Magnitude <= DETECTION_RANGE then
                if isGroundShot(child.Position) then
                    warn("[..] Detected potential ground shot at position:", child.Position)
                    -- Add your response logic here (dodge, alert, etc.)
                end
            end
        end
    end)
end)

print("€")

-- Toggle control
local desyncEnabled = false
local desyncLoop

-- Function to toggle desync
local function toggleDesync(state)
    desyncEnabled = state
    if desyncEnabled then
        -- Start desync loop
        desyncLoop = Run.Heartbeat:Connect(function()
            Init()
            Wait(timeRelease)
            
            local chokeClient, chokeServer = runBeatCon(runBeat, Sleep), runRenCon(runRen, Sleep)
            Wait(Ceil(Ping(statPing)) / 1000)
            
            chokeClient:Disconnect()
            chokeServer:Disconnect()
        end)
    else
        -- Stop desync loop
        if desyncLoop then
            desyncLoop:Disconnect()
            desyncLoop = nil
        end
    end
end

-- Toggle button setup
anti:AddToggle(
    "Enable Desync",
    {
        Text = "Invisible Desync",
        Default = false,
        Tooltip = "Enable or Disable the desync feature",
        Callback = function(state)
            toggleDesync(state)  -- Enable or disable desync based on button state
        end
    }
)

-- UI setup (example using your UI structure)
net:AddToggle(
    "Enable Network Sleep",
    {
        Text = "Network FF",
        Default = false,
        Tooltip = "Toggle to simulate network sleep and enhance lag",
        Callback = function(state)
            if state then
                -- Enable the "network sleep" behavior
                setfflag("S2PhysicsSenderRate", 2)
                local UserInputService = game:GetService("UserInputService")
                local Players = game:GetService("Players")
                local Client = Players.LocalPlayer

                local MainThread = task.spawn(function()
                    while state do
                        if Client.Character and Client.Character:FindFirstChild("HumanoidRootPart") then
                            sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", true)
                            task.wait()
                            sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", false)
                        end
                        task.wait()
                    end
                end)
            else
                -- Disable the "network sleep" behavior
                setfflag("S2PhysicsSenderRate", 13)
                local Client = Players.LocalPlayer
                if Client.Character and Client.Character:FindFirstChild("HumanoidRootPart") then
                    sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", false)
                end
            end
        end
    }
)

-- Main Script
game:GetService("RunService").Heartbeat:Connect(function()
    local player = game.Players.LocalPlayer
    local character = player.Character

    if character and character:FindFirstChild("HumanoidRootPart") then
        local humanoidRootPart = character.HumanoidRootPart
        local vel = humanoidRootPart.Velocity

        -- CFrame Speed Toggle
        if getgenv().cframespeedtoggle == true then
            humanoidRootPart.CFrame = humanoidRootPart.CFrame +
                character.Humanoid.MoveDirection * getgenv().speedvalue / 0.5
        end

        -- Anti Lock Functionality
        if getgenv().Venus and getgenv().Venus.AntiEnabled then
            if getgenv().Venus.AntiLock == "Predbreaker" then
                humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            elseif getgenv().Venus.AntiLock == "Sky" then
                humanoidRootPart.Velocity = Vector3.new(0, 100, 0)
            end
        end

        game:GetService("RunService").RenderStepped:Wait()
        humanoidRootPart.Velocity = vel
    end
end)

-- UI Toggle Button to Enable Anti Lock
ant:AddToggle(
    "Enable Anti Lock",
    {
        Text = "Enable Anti Lock",
        Default = false,  -- Default state is disabled
        Tooltip = "Toggle Anti Lock",
        Callback = function(state)
            getgenv().Venus = getgenv().Venus or {}  -- Ensure Venus table exists
            getgenv().Venus.AntiEnabled = state  -- Set AntiEnabled based on toggle state
        end
    }
)

-- Dropdown for Anti Lock Modes
ant:AddDropdown(
    "AntiLockMode",
    {
        Values = {"Sky", "Predbreaker"},
        Default = 1,  -- Default selection is "Sky"
        Multi = false,  -- Single selection
        Text = "Anti Lock Mode",
        Tooltip = "Choose Anti Lock mode",
        Callback = function(value)
            getgenv().Venus = getgenv().Venus or {}  -- Ensure Venus table exists
            getgenv().Venus.AntiLock = value  -- Set AntiLock mode
        end
    }
)

-- Create the toggle button in the UI
anti:AddToggle(
    "Desync Velocity",
    {
        Text = "Velocity Manipulation",
        Default = false,
        Tooltip = "Toggles the manipulation of velocity",
        Callback = function(state)
            getgenv().demisethebest = state  -- Toggle the velocity manipulation state
        end
    }
)

-- The script that manipulates the velocity
game:GetService("RunService").heartbeat:Connect(function()
    if getgenv().demisethebest == true then 
        local abc = game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity
        game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(1,1,1) * (2^16)
        game:GetService("RunService").RenderStepped:Wait()
        game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = abc
    end 
end)

local Plr = game.Players.LocalPlayer
local StateEnabled = false  -- Tracks if the feature is enabled or not

-- Add the toggle button
anti:AddToggle(
    "Enable Freefall Speed",
    {
        Text = "Freefall Velocity Boost",
        Default = false,
        Tooltip = "Enable faster freefall",
        Callback = function(state)
            StateEnabled = state  -- Update the state when the toggle is pressed
        end
    }
)

-- StateChanged event listener with the toggle
Plr.Character:WaitForChild("Humanoid").StateChanged:Connect(function(old, new)
    if StateEnabled and new == Enum.HumanoidStateType.Freefall then
        wait(0.27)
        game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, -15, 0)
    end
end)

-- Toggle button for enabling/disabling Underground
net:AddToggle(
    "Enable Underground",
    {
        Text = "Underground",
        Default = false,
        Tooltip = "Toggles the underground velocity manipulation",
        Callback = function(state)
            getgenv().Underground = state
        end
    }
)

-- Add an input to adjust the UndergroundAmount
net:AddInput(
    "Underground Amount",
    {
        Default = tostring(getgenv().UndergroundAmount),
        Numeric = true,
        Finished = true,
        Text = "Amount",
        Tooltip = "Adjust the downward velocity for the underground effect",
        Placeholder = "825",
        Callback = function(value)
            getgenv().UndergroundAmount = tonumber(value) or getgenv().UndergroundAmount
        end
    }
)

-- The script that manipulates underground velocity
getgenv().UndergroundAmount = 825
game:GetService("RunService").heartbeat:Connect(function()
    if getgenv().Underground then
        local vel = game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity
        game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, -getgenv().UndergroundAmount, 0)
        game:GetService("RunService").RenderStepped:Wait()
        game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = vel
    end
end)






-- Toggle Button for Venus (which also controls health bars)


local lplr = game.Players.LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera
local CurrentCamera = workspace.CurrentCamera
local worldToViewportPoint = CurrentCamera.worldToViewportPoint

local healthBarEnabled = false
local toolEspEnabled = false

esp:AddToggle(
    "Boxes & Health Bars",
    {
        Text = "Boxes & Health Bars",
        Default = false,
        Tooltip = "Enable or Disable Boxes and Health Bars",
        Callback = function(state)
            healthBarEnabled = state
        end
    }
)

esp:AddToggle(
    "Tool",
    {
        Text = "Tool",
        Default = false,
        Tooltip = "Tool Esp",
        Callback = function(state)
            toolEspEnabled = state
        end
    }
)

local HeadOff = Vector3.new(0, 0.5, 0)
local LegOff = Vector3.new(0, 3, 0)

local function createkhenBox(v)
    -- Skip creating ESP for local player
    if v == lplr then
        return
    end
    
    local BoxOutline = Drawing.new("Square")
    BoxOutline.Visible = false -- Keep this invisible
    BoxOutline.Color = Color3.new(0, 0, 0)
    BoxOutline.Thickness = 3
    BoxOutline.Transparency = 1
    BoxOutline.Filled = false

    local Box = Drawing.new("Square")
    Box.Visible = false -- This will be set to true when the player is visible
    Box.Color = Color3.new(1, 1, 1) -- White box
    Box.Thickness = 1
    Box.Transparency = 1
    Box.Filled = false

    local HealthBarOutline = Drawing.new("Line")
    HealthBarOutline.Thickness = 1.5 -- Stroke thickness
    HealthBarOutline.Color = Color3.new(0, 0, 0) -- Black stroke color
    HealthBarOutline.Visible = false

    local HealthBar = Drawing.new("Line")
    HealthBar.Thickness = 1.5 -- Line thickness for health bar
    HealthBar.Visible = false

    local ToolText = Drawing.new("Text")
    ToolText.Visible = false
    ToolText.Size = 11
    ToolText.Center = true
    ToolText.Outline = true
    ToolText.OutlineColor = Color3.new(0, 0, 0)
    ToolText.Color = Color3.new(1, 1, 1) -- White text

    local function boxesp()
        game:GetService("RunService").RenderStepped:Connect(function()
            -- Double check to make sure we're not drawing on local player
            if v == lplr then
                Box.Visible = false
                HealthBarOutline.Visible = false
                HealthBar.Visible = false
                ToolText.Visible = false
                return
            end
            
            if v.Character and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("HumanoidRootPart") and v.Character.Humanoid.Health > 0 then
                local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)

                local RootPart = v.Character.HumanoidRootPart
                local Head = v.Character.Head
                local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)
                local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position + HeadOff)
                local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - LegOff)

                if onScreen and healthBarEnabled then
                    Box.Size = Vector2.new(1000 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                    Box.Position = Vector2.new(RootPosition.X - Box.Size.X / 2, RootPosition.Y - Box.Size.Y / 2)
                    Box.Visible = true -- Only the white box is visible

                    -- Health bar
                    HealthBarOutline.From = Vector2.new(Box.Position.X - 6, Box.Position.Y)
                    HealthBarOutline.To = Vector2.new(Box.Position.X - 6, Box.Position.Y + (HeadPosition.Y - LegPosition.Y))
                    HealthBarOutline.Visible = true

                    local healthRatio = v.Character.Humanoid.Health / v.Character.Humanoid.MaxHealth
                    HealthBar.From = Vector2.new(Box.Position.X - 6, Box.Position.Y)
                    HealthBar.To = Vector2.new(Box.Position.X - 6, Box.Position.Y + (HeadPosition.Y - LegPosition.Y) * healthRatio)
                    HealthBar.Color = Color3.fromRGB(255 * (1 - healthRatio), 255 * healthRatio, 0) -- Health color
                    HealthBar.Visible = true
                else
                    Box.Visible = false -- Hide the white box if conditions aren't met
                    HealthBarOutline.Visible = false
                    HealthBar.Visible = false
                end
                
                -- Tool ESP
                if onScreen and toolEspEnabled then
                    local toolName = "None"
                    if v.Character:FindFirstChildOfClass("Tool") then
                        toolName = v.Character:FindFirstChildOfClass("Tool").Name
                    end
                    
                    ToolText.Text = toolName
                    ToolText.Position = Vector2.new(RootPosition.X, LegPosition.Y + 10)
                    ToolText.Visible = true
                else
                    ToolText.Visible = false
                end
            else
                Box.Visible = false -- Hide the white box if the character isn't valid
                HealthBarOutline.Visible = false
                HealthBar.Visible = false
                ToolText.Visible = false
            end
        end)
    end
    coroutine.wrap(boxesp)()
end

for _, v in pairs(game.Players:GetChildren()) do
    createkhenBox(v)
end

game.Players.PlayerAdded:Connect(function(v)
    createkhenBox(v)
end)

local lplr = game.Players.LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera
local CurrentCamera = workspace.CurrentCamera
local worldToViewportPoint = CurrentCamera.worldToViewportPoint

_G.TeamCheck = false -- Default team check is off
local tracersEnabled = false -- Default tracers are off

-- Add Toggle for Tracers
esp:AddToggle(
    "Tracers",
    {
        Text = "Tracers",
        Default = false,
        Tooltip = "Enable or disable Tracers",
        Callback = function(state)
            tracersEnabled = state
        end
    }
)

for i,v in pairs(game.Players:GetChildren()) do
    local Tracer = Drawing.new("Line")
    Tracer.Visible = false
    Tracer.Color = Color3.new(1, 1, 1)
    Tracer.Thickness = 1
    Tracer.Transparency = 1

    function lineesp()
        game:GetService("RunService").RenderStepped:Connect(function()
            if tracersEnabled and v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                local Vector, OnScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)

                if OnScreen then
                    Tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                    Tracer.To = Vector2.new(Vector.X, Vector.Y)

                    if _G.TeamCheck and v.TeamColor == lplr.TeamColor then
                        -- Teammates
                        Tracer.Visible = false
                    else
                        -- Enemies
                        Tracer.Visible = true
                    end
                else
                    Tracer.Visible = false
                end
            else
                Tracer.Visible = false
            end
        end)
    end
    coroutine.wrap(lineesp)()
end

game.Players.PlayerAdded:Connect(function(v)
    local Tracer = Drawing.new("Line")
    Tracer.Visible = false
    Tracer.Color = Color3.new(1, 1, 1)
    Tracer.Thickness = 1
    Tracer.Transparency = 1

    function lineesp()
        game:GetService("RunService").RenderStepped:Connect(function()
            if tracersEnabled and v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                local Vector, OnScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)

                if OnScreen then
                    Tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                    Tracer.To = Vector2.new(Vector.X, Vector.Y)

                    if _G.TeamCheck and v.TeamColor == lplr.TeamColor then
                        -- Teammates
                        Tracer.Visible = false
                    else
                        -- Enemies
                        Tracer.Visible = true
                    end
                else
                    Tracer.Visible = false
                end
            else
                Tracer.Visible = false
            end
        end)
    end
    coroutine.wrap(lineesp)()
end)

-- Separate functionality loop
game:GetService("RunService").Heartbeat:Connect(function()
    if getgenv().FeatureEnabled then
        -- Place your functionality code here
        -- This code will only execute if FeatureEnabled is true
    end
end)

-- Dropdown list for Crosshair Toggle
local CrosshairEnabled = false

visuals:AddToggle(
    "Crosshair",
    {
        Text = "Crosshair",
        Default = false,
        Tooltip = "Enable or disable Crosshair",
        Callback = function(state)
            CrosshairEnabled = state
        end
    }
)

-- Crosshair settings
getgenv().crosshair = {
    enabled = true,
    refreshrate = 0.015,
    mode = 'center',
    position = Vector2.new(0, 0),
    width = 2.5,
    length = 10,
    radius = 11,
    color = Color3.fromRGB(86, 87, 142),  -- Color for the crosshair lines
    spin = true,
    spin_speed = 150,
    spin_max = 340,
    spin_style = Enum.EasingStyle.Circular,
    resize = true,
    resize_speed = 150,
    resize_min = 5,
    resize_max = 22,
}

local old; old = hookfunction(Drawing.new, function(class, properties)
    local drawing = old(class)
    for i, v in next, properties or {} do
        drawing[i] = v
    end
    return drawing
end)

local runservice = game:GetService('RunService')
local inputservice = game:GetService('UserInputService')
local tweenservice = game:GetService('TweenService')
local camera = workspace.CurrentCamera

local last_render = 0

local drawings = {
    crosshair = {},
    text = {
        Drawing.new('Text', {Size = 13, Font = 2, Outline = true, Text = 'im', Color = Color3.new(255, 255, 255)}),
        Drawing.new('Text', {Size = 13, Font = 2, Outline = true, Text = 'khen', Color = Color3.fromRGB(86, 87, 142)}),
    }
}

for idx = 1, 4 do
    drawings.crosshair[idx] = Drawing.new('Line')
    drawings.crosshair[idx + 4] = Drawing.new('Line')
end

function solve(angle, radius)
    return Vector2.new(
        math.sin(math.rad(angle)) * radius,
        math.cos(math.rad(angle)) * radius
    )
end

runservice.PostSimulation:Connect(function()
    local _tick = tick()

    if _tick - last_render > crosshair.refreshrate then
        last_render = _tick

        local position = camera.ViewportSize / 2

        local text_1 = drawings.text[1]
        local text_2 = drawings.text[2]

        text_1.Visible = CrosshairEnabled
        text_2.Visible = CrosshairEnabled

        if CrosshairEnabled then
            local text_x = text_1.TextBounds.X + text_2.TextBounds.X

            text_1.Position = position + Vector2.new(-text_x / 2, crosshair.radius + (crosshair.resize and crosshair.resize_max or crosshair.length) + 5)
            text_2.Position = text_1.Position + Vector2.new(text_1.TextBounds.X, 0)
            text_2.Color = Color3.fromRGB(86, 87, 142)

            for idx = 1, 4 do
                local outline = drawings.crosshair[idx]
                local inline = drawings.crosshair[idx + 4]

                local angle = (idx - 1) * 90
                local length = crosshair.length

                if crosshair.spin then
                    local spin_angle = -_tick * crosshair.spin_speed % crosshair.spin_max
                    angle = angle + tweenservice:GetValue(spin_angle / 360, crosshair.spin_style, Enum.EasingDirection.InOut) * 360
                end

                if crosshair.resize then
                    local resize_length = tick() * crosshair.resize_speed % 180
                    length = crosshair.resize_min + math.sin(math.rad(resize_length)) * crosshair.resize_max
                end

                inline.Visible = true
                inline.Color = Color3.fromRGB(86, 87, 142)  -- Set color for all inline lines
                inline.From = position + solve(angle, crosshair.radius)
                inline.To = position + solve(angle, crosshair.radius + length)
                inline.Thickness = crosshair.width

                outline.Visible = true
                outline.From = position + solve(angle, crosshair.radius - 1)
                outline.To = position + solve(angle, crosshair.radius + length + 1)
                outline.Thickness = crosshair.width + 1.5    
            end
        else
            for idx = 1, 4 do
                drawings.crosshair[idx].Visible = false
                drawings.crosshair[idx + 4].Visible = false
            end
        end
    end
end)

local effectEnabled = false -- Variable to control the toggle state
local forceFieldColor = Color3.fromRGB(128, 0, 128) -- Default force field color (purple)

-- Toggle Button for Effect
visuals:AddToggle(
    "Visuals",
    {
        Text = "Force Field", -- 
        Default = false,
        Tooltip = "Enable or disable the effect on MeshParts ",
        Callback = function(state)
            effectEnabled = state
        end
    }
)

-- Color Picker for Force Field Color
Toggles.Visuals:AddColorPicker(
    "Color",
    {
        Default = Color3.fromRGB(128, 0, 128), -- Default purple color
        Title = "Force Field Color", -- Tooltip for the picker
        Callback = function(color)
            forceFieldColor = color -- Update the color variable dynamically
        end
    }
)

-- Apply effect if enabled
spawn(function()
    while wait() do
        for _, part in pairs(game.Players.LocalPlayer.Character:GetChildren()) do
            if part:IsA("MeshPart") then
                if effectEnabled then
                    part.Material = Enum.Material.ForceField
                    part.Color = forceFieldColor -- Use the dynamically updated color
                else
                    -- Revert to original properties
                    part.Material = Enum.Material.SmoothPlastic -- Change this to the original material you want
                end
            end
        end
    end
end)

visuals:AddLabel('')



local circle  -- Declare the circle variable outside the function

-- Function to create or get the circle
local function getCircle()
    if not circle then
        -- Initialize the circle if it doesn't exist
        circle = Drawing.new("Circle")
        circle.Position = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)  -- Centered on the screen
        circle.Radius = 120  -- Default radius
        circle.Color = Color3.fromRGB(255, 255, 255)  -- Default color (white)
        circle.Thickness = 1
        circle.Filled = false  -- Default filled state
    end
    return circle
end

-- State variable to track circle visibility
local circleEnabled = false

-- State variable to track circle fill
local circleFilled = false

-- Toggle button for circle visibility
fov:AddToggle(
    "Enable Circle", 
    {
        Text = "Enable Circle",
        Default = false,
        Tooltip = "Toggle to enable or disable the circle",
        Callback = function(state)
            circleEnabled = state
            local circleInstance = getCircle()
            circleInstance.Visible = circleEnabled
        end
    }
)

-- Toggle button for filling the circle
fov:AddToggle(
    "Filled",
    {
        Text = "Filled",
        Default = false,
        Tooltip = "Toggle to fill the circle",
        Callback = function(state)
            circleFilled = state
            local circleInstance = getCircle()  -- Get the circle instance
            circleInstance.Filled = circleFilled  -- Update filled state
        end
    }
)

-- Slider for circle size adjustment
fov:AddSlider(
    "Circle Size",
    {
        Min = 20,  -- Minimum size
        Max = 300,  -- Maximum size
        Default = 120,  -- Default size (initial radius)
        Rounding = 0,  -- Add rounding value
        Text = "Circle Size",
        Tooltip = "Adjust the size of the circle",
        Callback = function(size)
            local circleInstance = getCircle()  -- Get the circle instance
            if circleInstance then  -- Ensure circleInstance is valid
                circleInstance.Radius = size  -- Set the new radius
            end
        end
    }
)

-- Color Picker to change circle color
fov:AddLabel('Circle Color'):AddColorPicker('ColorPicker', {
    Default = circle and circle.Color or Color3.fromRGB(255, 255, 255),  -- Start with the current circle color or default to white
    Title = 'Circle Color',  -- Title for the color picker
    Transparency = nil,  -- Optional. Enables transparency changing for this color picker (leave as nil to disable)

    Callback = function(Value)
        local circleInstance = getCircle()  -- Get the circle instance
        if circleInstance then  -- Ensure circleInstance is valid
            circleInstance.Color = Value  -- Change the circle color
        end
        print('[cb] Color changed!', Value)
    end
})

-- Initial drawing of the circle based on the default state
local circleInstance = getCircle()
circleInstance.Visible = circleEnabled









-- Variables
local speedd = 50
local screenGui = nil
local isToggleEnabled = false

local function createWalkSpeedGUI()
    if screenGui then
        screenGui:Destroy()
    end

    screenGui = Instance.new("ScreenGui")
    screenGui.Name = "WalkSpeedGui"
    screenGui.Parent = game.CoreGui
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.ResetOnSpawn = false

    -- Nút WalkSpeed với style mới
    local button = Instance.new("TextButton")
    button.Name = "WalkSpeedButton"
    button.Parent = screenGui
    button.Active = true
    button.Draggable = true
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- nền dịu
    button.BackgroundTransparency = 0.3
    button.Size = UDim2.new(0, 120, 0, 50)
    button.Position = UDim2.new(1, -150, 0, 80)
    button.Text = "WalkSpeed OFF"
    button.TextColor3 = Color3.fromRGB(180, 220, 200) -- xanh ngọc nhạt dịu mắt
    button.TextScaled = false
    button.TextSize = 14
    button.Font = Enum.Font.Gotham
    button.BorderSizePixel = 0

    -- Bo góc
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 15)
    buttonCorner.Parent = button

    -- Viền
    local buttonStroke = Instance.new("UIStroke")
    buttonStroke.Color = Color3.fromRGB(200, 255, 200) -- viền xanh nhạt
    buttonStroke.Thickness = 2
    buttonStroke.Parent = button

    -- WalkSpeed functionality
    local humanoid
    local isEnabled = false
    local originalSpeed = 16

    local function UpdateWalkSpeed()
        if humanoid then
            if isEnabled then
                humanoid.WalkSpeed = speedd
            else
                humanoid.WalkSpeed = originalSpeed
            end
        end
    end

    local function UpdateButtonAppearance()
        if isEnabled then
            button.BackgroundColor3 = Color3.fromRGB(50, 120, 50) -- xanh lá khi bật
            button.Text = "WalkSpeed ON"
            buttonStroke.Color = Color3.fromRGB(150, 255, 180)
        else
            button.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- xám khi tắt
            button.Text = "WalkSpeed OFF"
            buttonStroke.Color = Color3.fromRGB(200, 255, 200)
        end
    end

    local function onCharacterAdded(character)
        humanoid = character:WaitForChild("Humanoid")
        originalSpeed = humanoid.WalkSpeed
        
        -- Monitor walkspeed changes
        local connection
        connection = humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
            if isEnabled and humanoid.WalkSpeed ~= speedd then
                humanoid.WalkSpeed = speedd
            elseif not isEnabled and humanoid.WalkSpeed ~= originalSpeed then
                originalSpeed = humanoid.WalkSpeed
            end
        end)
        
        -- Clean up connection when character is removed
        character.AncestryChanged:Connect(function()
            if not character.Parent then
                connection:Disconnect()
            end
        end)
        
        UpdateWalkSpeed()
        UpdateButtonAppearance()
    end

    -- Connect character events
    local player = game.Players.LocalPlayer
    player.CharacterAdded:Connect(onCharacterAdded)

    if player.Character then
        onCharacterAdded(player.Character)
    end

    -- Button click to toggle on/off
    button.MouseButton1Click:Connect(function()
        isEnabled = not isEnabled
        UpdateWalkSpeed()
        UpdateButtonAppearance()
    end)

    -- Hover effects
    button.MouseEnter:Connect(function()
        button.BackgroundTransparency = 0.15
        button.TextColor3 = Color3.fromRGB(220, 255, 230) -- sáng hơn chút khi hover
        if isEnabled then
            buttonStroke.Color = Color3.fromRGB(150, 255, 150)
        else
            buttonStroke.Color = Color3.fromRGB(150, 255, 180)
        end
    end)

    button.MouseLeave:Connect(function()
        button.BackgroundTransparency = 0.3
        button.TextColor3 = Color3.fromRGB(180, 220, 200) -- quay về dịu
        UpdateButtonAppearance()
    end)
end

-- Linoria Integration (only if walkspeed variable exists)
if walkspeed then
    walkspeed:AddToggle(
        "WalkSpeedToggle",
        {
            Text = "Walk Speed GUI",
            Default = false,
            Tooltip = "Show/Hide WalkSpeed GUI",
            Callback = function(state)
                isToggleEnabled = state
                if state then
                    createWalkSpeedGUI()
                else
                    if screenGui then
                        screenGui:Destroy()
                        screenGui = nil
                    end
                end
            end
        }
    )

    walkspeed:AddInput(
        "WalkSpeedValue",
        {
            Default = "50",
            Numeric = true,
            Finished = false,
            Text = "WalkSpeed Value",
            Tooltip = "Set custom walkspeed value (default: 50)",
            Placeholder = "Enter speed value",
            Callback = function(value)
                local num = tonumber(value)
                if num and num > 0 and num <= 1000 then -- Add reasonable upper limit
                    speedd = num
                    print("WalkSpeed set to: " .. num) -- Debug output
                else
                    warn("Invalid walkspeed value. Must be between 1-1000")
                end
            end
        }
    )
else
    warn("lol")
end




local macroGroup = Tabs.More:AddRightGroupbox("Macro")


local function spawnMacroButton()
    local player = game.Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    local userInputService = game:GetService("UserInputService")
    local lastMacroPosition = nil -- Biến lưu vị trí MacroButton

    local function setupGui()
        local screenGui = playerGui:FindFirstChild("MacroScreenGui") or Instance.new("ScreenGui", playerGui)
        screenGui.Name = "MacroScreenGui"
        screenGui.ResetOnSpawn = false

        local MacroButton = screenGui:FindFirstChild("MacroButton") or Instance.new("TextButton", screenGui)
        MacroButton.Name = "MacroButton"
        MacroButton.Size = UDim2.new(0, 100, 0, 50)
        MacroButton.Position = lastMacroPosition or UDim2.new(0.5, 150, 0.8, -225)
        MacroButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        MacroButton.BackgroundTransparency = 0.45
        MacroButton.Text = "Macro OFF"
        MacroButton.TextColor3 = Color3.fromRGB(200, 200, 200)
        MacroButton.TextScaled = false
        MacroButton.TextSize = 14
        MacroButton.Font = Enum.Font.Gotham
        MacroButton.BorderSizePixel = 0
        MacroButton.Active = true
        MacroButton.Draggable = true

        local UICorner = Instance.new("UICorner", MacroButton)
        UICorner.CornerRadius = UDim.new(0, 15)

        local UIStroke = Instance.new("UIStroke", MacroButton)
        UIStroke.Color = Color3.fromRGB(255, 255, 255)
        UIStroke.Thickness = 2

        local isMacroEnabled = false
        local macroConnection

        local function updateMacroButtonAppearance()
            if isMacroEnabled then
                MacroButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
                MacroButton.Text = "Macro ON"
                UIStroke.Color = Color3.fromRGB(150, 255, 150)
            else
                MacroButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
                MacroButton.Text = "Macro OFF"
                UIStroke.Color = Color3.fromRGB(255, 255, 255)
            end
        end

        MacroButton.MouseButton1Click:Connect(function()
            isMacroEnabled = not isMacroEnabled
            updateMacroButtonAppearance()

            if isMacroEnabled then
                macroConnection = game:GetService("RunService").RenderStepped:Connect(function()
                    local character = player.Character
                    if character and character:FindFirstChild("HumanoidRootPart") then
                        local camera = workspace.CurrentCamera
                        local rootPart = character.HumanoidRootPart
                        local cameraDirection = camera.CFrame.LookVector
                        rootPart.CFrame = CFrame.new(rootPart.Position, rootPart.Position + Vector3.new(cameraDirection.X, 0, cameraDirection.Z))
                    end
                end)
                if notificationsEnabled then
                    NotificationSystem:Notify("Macro Enabled", 3)
                end
            else
                if macroConnection then
                    macroConnection:Disconnect()
                    macroConnection = nil
                end
                if notificationsEnabled then
                    NotificationSystem:Notify("Macro Disabled", 3)
                end
            end
        end)

        MacroButton.MouseEnter:Connect(function()
            MacroButton.BackgroundTransparency = 0.1
            MacroButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            UIStroke.Color = isMacroEnabled and Color3.fromRGB(180, 255, 180) or Color3.fromRGB(200, 200, 200)
        end)

        MacroButton.MouseLeave:Connect(function()
            MacroButton.BackgroundTransparency = 0.45
            MacroButton.TextColor3 = Color3.fromRGB(200, 200, 200)
            updateMacroButtonAppearance()
        end)

        MacroButton:GetPropertyChangedSignal("Position"):Connect(function()
            lastMacroPosition = MacroButton.Position
        end)

        updateMacroButtonAppearance()
    end

    setupGui()

    game.Players.LocalPlayer.CharacterAdded:Connect(function()
        setupGui()
    end)
end



macroGroup:AddButton('Load Macro', function()
    spawnMacroButton()

    if notificationsEnabled then
        Library:Notify('Macro Button Loaded', 3)
    end
end)

local creditGroup = Tabs.Credit:AddLeftGroupbox("Credits")

creditGroup:AddLabel("")
creditGroup:AddLabel("Developer: Tuan Khen")
creditGroup:AddLabel("")
creditGroup:AddLabel("Ideator: @doibuonjwkkjjk\n in tiktok")








        
local MenuGroup = Tabs['UI Settings']:AddRightGroupbox('Menu')

MenuGroup:AddButton('Unload', function() Library:Unload() end)
MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', { Default = 'End', NoUI = true, Text = 'Menu keybind' })

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

if not isfolder("failurty") then makefolder("failurty") end
if not isfolder("failurty/configss") then makefolder("failurty/configss") end

ThemeManager:SetFolder('failurty.CC')
SaveManager:SetFolder('failurty/configss')

SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])

SaveManager:LoadAutoloadConfig()






print("hahah")



local userInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")


local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local player = game.Players.LocalPlayer



local userInputService = game:GetService("UserInputService")

local AimlockState = true
local Locked = false
local Victim
local target

if venus.Loaded then
    notify("Venus.CC is Already Loaded!")
    return
end

venus.Loaded = true

local function GetClosestPlayer()
    local closestPlayer = nil
    local shortestScore = math.huge
    local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local maxAngle = 30 -- Maximum angle limit in degrees (adjust this for wider or narrower locking range)

    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= player and plr.Character and plr.Character:FindFirstChild(venus.AimPart) and plr.Character:FindFirstChild("Humanoid") and plr.Character.Humanoid.Health > 0 then
            local part = plr.Character[venus.AimPart]
            local relativePos = part.Position - Camera.CFrame.Position
            local playerDistance = relativePos.Magnitude
            local screenPosition, onScreen = Camera:WorldToViewportPoint(part.Position)

            if onScreen then
                local angle = math.deg(math.acos(Camera.CFrame.LookVector:Dot(relativePos.Unit)))
                
                -- Only consider players within a specific angle range (in front of you)
                if angle <= maxAngle then
                    local mouseDistance = (Vector2.new(screenPosition.X, screenPosition.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude

                    -- Adjust score to prioritize players more in front and reduce side locks
                    local score = mouseDistance * 0.02 + angle * 0.03 -- Increase angle weight to penalize wider angles
                    
                    if angle < 5 then
                        score = score * 0.001 -- Further reduce score for players directly in front
                    end

                    local ray = Ray.new(Camera.CFrame.Position, relativePos.Unit * playerDistance)
                    local hitPart = WS:FindPartOnRayWithIgnoreList(ray, {player.Character})

                    if (not hitPart or hitPart:IsDescendantOf(plr.Character)) and score < shortestScore then
                        closestPlayer = plr
                        shortestScore = score
                    end
                end
            end
        end
    end

    return closestPlayer
end

local notificationsEnabled = false -- Default state for notifications

assist:AddToggle(
    "Enable Notifications",
    {
        Text = "Notifications",
        Default = false,
        Tooltip = "Enable or disable notifications",
        Callback = function(state)
            notificationsEnabled = state
        end
    }
)

local function ToggleLock()
    if AimlockState then
        Locked = not Locked
        if Locked then
            Victim = GetClosestPlayer()
            target = Victim
            if Victim and Victim.Character and Victim.Character:FindFirstChild(venus.AimPart) then
                -- Change image to locked state when a valid target is found
                if LockButton then
                    LockButton.Image = "rbxassetid://96734356722259" -- Image for the lock when locked
                end
                if venus.Enabled and notificationsEnabled then
                    NotificationSystem:Notify("Camlock: Locked onto " .. tostring(Victim.Name), 5)
                elseif targetaim.enabled and notificationsEnabled then
                    NotificationSystem:Notify("Target Lock: Locked onto " .. tostring(target.Name), 5)
                end
            else
                -- No valid target found, revert to unlocked state
                Locked = false
                Victim = nil
                target = nil
                if LockButton then
                    LockButton.Image = "rbxassetid://88399410034249" -- Image for the lock when unlocked
                end
                if venus.Enabled and notificationsEnabled then
                    NotificationSystem:Notify("Camlock: No target found", 5)
                elseif targetaim.enabled and notificationsEnabled then
                    NotificationSystem:Notify("Target Lock: No target found", 5)
                end
            end
        else
            -- Unlock state
            if LockButton then
                LockButton.Image = "rbxassetid://88399410034249" -- Image for the lock when unlocked
            end
            Victim = nil
            target = nil
            if venus.Enabled and notificationsEnabled then
                NotificationSystem:Notify("Camlock: Unlocked!", 5)
            elseif targetaim.enabled and notificationsEnabled then
                NotificationSystem:Notify("Target Lock: Unlocked!", 5)
            end
        end
    else
        if not venus.Enabled and notificationsEnabled then
            NotificationSystem:Notify("Camlock not enabled", 5)
        end
    end
end

-- Function for the "Button" mode
function spawnButton()
    local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local function setupGui()
        local screenGui = playerGui:FindFirstChild("LockScreenGui")

        if not screenGui then
            screenGui = Instance.new("ScreenGui")
            screenGui.Name = "LockScreenGui"
            screenGui.Parent = playerGui
            screenGui.ResetOnSpawn = false -- Prevent GUI from resetting on respawn
        end

        LockButton = screenGui:FindFirstChild("LockButton")

        if not LockButton then
            LockButton = Instance.new("ImageButton")
            LockButton.Name = "LockButton"
            LockButton.Size = UDim2.new(0, 80, 0, 80)
            LockButton.Position = UDim2.new(0.5, -250, 0.8, -225)
            LockButton.Image = "rbxassetid://88399410034249" -- Default image for the lock (not locked)
            LockButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
            LockButton.BackgroundTransparency = 0.450
            LockButton.Parent = screenGui
            LockButton.Active = true
            LockButton.Draggable = true

            local UICorner = Instance.new("UICorner")
            UICorner.CornerRadius = UDim.new(0, 10)
            UICorner.Parent = LockButton

            LockButton.MouseButton1Click:Connect(function()
                ToggleLock() -- Trigger ToggleLock when clicked
            end)
        end
    end

    setupGui()

    -- Re-setup the GUI when the character respawns
    game.Players.LocalPlayer.CharacterAdded:Connect(function()
        setupGui()
        -- Ensure the button image reflects the current lock state after respawn
        if Locked and Victim then
            LockButton.Image = "rbxassetid://96734356722259"
        else
            LockButton.Image = "rbxassetid://88399410034249"
        end
    end)
end

-- Immediately call the function to create the button
spawnButton()

-- Re-setup the GUI when the character respawns
game.Players.LocalPlayer.CharacterAdded:Connect(function()
    spawnButton()
end)

RS.RenderStepped:Connect(function()
    if AimlockState and Victim and Victim.Character and Victim.Character:FindFirstChild(venus.AimPart) then
        local aimPart = Victim.Character[venus.AimPart]

        -- Single Prediction Calculation
        local predictedPosition = aimPart.Position 
            + aimPart.Velocity * venus.Prediction
            + Vector3.new(0, venus.JumpOffset, 0)

        -- Look at the target smoothly only if LookAt is enabled and target aim is active
        if venus.LookAtEnabled and targetaim.enabled then
            local lookPosition = CFrame.new(Camera.CFrame.p, predictedPosition)
            Camera.CFrame = Camera.CFrame:Lerp(lookPosition, venus.Smoothness)

            local playerHRP = player.Character.HumanoidRootPart
            playerHRP.CFrame = CFrame.new(playerHRP.Position, Vector3.new(predictedPosition.X, playerHRP.Position.Y, predictedPosition.Z))
        end

        -- Camlock functionality
        if AimlockState then
            local playerHRP = player.Character.HumanoidRootPart
            local camlockPosition = CFrame.new(Camera.CFrame.p, predictedPosition)
            Camera.CFrame = Camera.CFrame:Lerp(camlockPosition, venus.Smoothness)

            -- Target strafe functionality (Orbiting)
            if venus.cframe.TargetStrafe.Enabled then
                local lp = player.Character
                local targpos = Victim.Character.HumanoidRootPart.Position
                
                -- Calculate strafe offset for orbiting
                local angle = tick() * venus.cframe.TargetStrafe.StrafeSpeed
                local strafeOffset = Vector3.new(
                    math.cos(angle) * venus.cframe.TargetStrafe.StrafeRadius,
                    venus.cframe.TargetStrafe.Height,
                    math.sin(angle) * venus.cframe.TargetStrafe.StrafeRadius
                )

                local strafePosition = targpos + strafeOffset
                strafePosition = Vector3.new(strafePosition.X, math.max(strafePosition.Y, targpos.Y), strafePosition.Z)
                
                lp:SetPrimaryPartCFrame(CFrame.new(strafePosition))
                playerHRP.CFrame = CFrame.new(
                    playerHRP.Position,
                    Vector3.new(targpos.X, playerHRP.Position.Y, targpos.Z)
                )
            end
        end

        -- Auto Air functionality
        if venus.AutoAirEnabled then
            local TargetRootPart = Victim.Character:FindFirstChild("HumanoidRootPart")
            if TargetRootPart then
                local TargetVel = TargetRootPart.Velocity
                if TargetVel.Y > 25 then
                    local Character = LocalPlayer.Character
                    if Character then
                        local Tool = Character:FindFirstChildOfClass("Tool")
                        if Tool then
                            Tool:Activate()
                        end
                    end
                end
            end
        end
    end
end)


local mt = getrawmetatable(game)
local oldNamecall = mt.__namecall
setreadonly(mt, false)




mt.__namecall = newcclosure(function(Self, ...)
    local args = {...}
    local methodName = getnamecallmethod()

    if targetaim.enabled then
        if not checkcaller() and methodName == "FireServer" then
            for i, Argument in ipairs(args) do
                if typeof(Argument) == "Vector3" and target and target.Character then
                    local targetPart = target.Character[targetaim.targetPart]
                    if targetPart then
                        local adjustedPosition = targetPart.Position + (targetPart.Velocity * venus.Prediction)
                        
                        local jumpOffset = venus.JumpOffset or 0.04
                        if math.abs(targetPart.Velocity.Y) < 3 then
                            adjustedPosition = Vector3.new(adjustedPosition.X, adjustedPosition.Y + jumpOffset, adjustedPosition.Z)
                        end
                        
                        args[i] = adjustedPosition
                        return oldNamecall(Self, unpack(args))
                    end
                end
            end
        end
    end

    return oldNamecall(Self, ...)
end)

setreadonly(mt, true)






setreadonly(mt, true)

while task.wait() do
    if venus.Enabled and venus.AutoPred then
        local pingValue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local ping = tonumber((pingValue:match("%d+")))

        if ping then
            if ping > 225 then
                venus.Prediction = 0.166547
            elseif ping > 215 then
                venus.Prediction = 0.15692
            elseif ping > 205 then
                venus.Prediction = 0.165732
            elseif ping > 190 then
                venus.Prediction = 0.1690
            elseif ping > 185 then
                venus.Prediction = 0.1235666
            elseif ping > 180 then
                venus.Prediction = 0.16779123
            elseif ping > 175 then
                venus.Prediction = 0.165455312399999
            elseif ping > 170 then
                venus.Prediction = 0.16
            elseif ping > 165 then
                venus.Prediction = 0.15
            elseif ping > 160 then
                venus.Prediction = 0.1223333
            elseif ping > 155 then
                venus.Prediction = 0.125333
            elseif ping > 150 then
                venus.Prediction = 0.1652131
            elseif ping > 145 then
                venus.Prediction = 0.129934
            elseif ping > 140 then
                venus.Prediction = 0.1659921
            elseif ping > 135 then
                venus.Prediction = 0.1659921
            elseif ping > 130 then
                venus.Prediction = 0.12399
            elseif ping > 125 then
                venus.Prediction = 0.15465
            elseif ping > 110 then
                venus.Prediction = 0.142199
            elseif ping > 105 then
                venus.Prediction = 0.141199
            elseif ping > 100 then
                venus.Prediction = 0.134143
            elseif ping > 90 then
                venus.Prediction = 0.1433333333392
            elseif ping > 80 then
                venus.Prediction = 0.143214443
            elseif ping > 70 then
                venus.Prediction = 0.14899911
            elseif ping > 60 then
                venus.Prediction = 0.148325
            elseif ping > 50 then
                venus.Prediction = 0.128643
            elseif ping > 40 then
                venus.Prediction = 0.12766
            elseif ping > 30 then
                venus.Prediction = 0.124123
            elseif ping > 20 then
                venus.Prediction = 0.12435
            elseif ping > 10 then
                venus.Prediction = 0.1234555
            elseif ping < 10 then
                venus.Prediction = 0.1332
            else
                venus.Prediction = 0.1342
            end
        end
    end
end






if desync.sky == true then
    getgenv().VenusSky = true 
    getgenv().SkyAmount = 90

    game:GetService("RunService").Heartbeat:Connect(function()
        if getgenv().VenusSky then 
            local vel = game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity
            game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, getgenv().SkyAmount, 0) 
            game:GetService("RunService").RenderStepped:Wait()
            game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = vel
        end
    end)
end

if desync.jump == true then
    getgenv().jumpanti = true
    
    game:GetService("RunService").Heartbeat:Connect(function()
        if getgenv().jumpanti then    
            local CurrentVelocity = game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity
            game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(1000, 1000, 1000)
            game:GetService("RunService").RenderStepped:Wait()
            game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = CurrentVelocity
        end
    end)
end

if desync.jump == true then

-- Maximum Roblox velocity (128^2 or 16384)
local velMax = (128 ^ 2)

local timeRelease, timeChoke = 0.015, 0.105

local Property, Wait = sethiddenproperty, task.wait
local Radian, Random, Ceil = math.rad, math.random, math.ceil
local Angle = CFrame.Angles
local Vector = Vector3.new
local Service = game.GetService

local Run = Service(game, 'RunService')
local Stats = Service(game, 'Stats')
local Players = Service(game, 'Players')
local LocalPlayer = Players.LocalPlayer
local statPing = Stats.PerformanceStats.Ping
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Root = Character:WaitForChild("HumanoidRootPart")
local Mouse = LocalPlayer:GetMouse()

local runRen, runBeat = Run.RenderStepped, Run.Heartbeat
local runRenWait, runRenCon = runRen.Wait, runRen.Connect
local runBeatCon = runBeat.Connect

local function Ping()
    return statPing:GetValue()
end

local function Sleep()
    Property(Root, 'NetworkIsSleeping', true)
end

local function FireGun()
    local tool = LocalPlayer.Character:FindFirstChildOfClass("Tool")
    if tool and tool:FindFirstChild("Shoot") then
        local ShootEvent = tool.Shoot
        ShootEvent:FireServer(Mouse.Hit.Position)
    end
end

local function Init()
    if not Root then return end

    local rootVel = Root.Velocity
    local rootCFrame = Root.CFrame

   
    local rootAng = Random(-180, 180)
    local rootOffset do
        local X = Random(-velMax, velMax)
        local Y = Random(0, velMax)
        local Z = Random(-velMax, velMax)
        rootOffset = Vector(X, -Y, Z)
    end

    Root.CFrame = Angle(0, Radian(rootAng), 0)
    Root.Velocity = rootOffset

   
    FireGun()


    runRenWait(runRen)
    Root.CFrame = rootCFrame
    Root.Velocity = rootVel
end

runBeatCon(runBeat, Init)

-- Main loop for choking replication
while Wait(timeRelease) do
    -- Stable replication packets
    local chokeClient, chokeServer = runBeatCon(runBeat, Sleep), runRenCon(runRen, Sleep)

    Wait(Ceil(Ping()) / 1000)

    chokeClient:Disconnect()
    chokeServer:Disconnect()

end
end

if desync.network == true then
local RunService = game:GetService("RunService")

local function onHeartbeat()
    setfflag("S2PhysicsSenderRate", 1)
end

RunService.Heartbeat:Connect(onHeartbeat)
end

if Misc.LowGfx == true then
game:GetService("CorePackages").Packages:Destroy()
end

if FPSunlocker.Enabled then
    setfpscap(FPSunlocker.FPSCap)
end
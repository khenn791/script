setfpscap(9999)

loadstring(game:HttpGet("https://raw.githubusercontent.com/khenn791/script-khen/refs/heads/main/larplarpbypasser.txt"))()

loadstring(game:HttpGet("https://raw.githubusercontent.com/aa8283/i/refs/heads/main/Protected_2547730226887233.txt"))()



game:GetService("StarterGui"):SetCore("SendNotification", {
    Title = "Loading...",
    Text = "wait",
    Duration = 3
})


print("khen hate girls")

getgenv().imkhen = {
  ["Enabled"] = true,
  ["Prediction"] = 0.152,
  ["KeyBind"] = Enum.KeyCode.C,
  ["Smoothness"] = 0.29732,
  ["AimPart"] = "UpperTorso",
  ["AutoPrediction"] = false,
  ["AutoPredMode"] = "Math",
  ["JumpOffset"] = 3,
}
  
getgenv().TargetAim = {
    ["Enabled"] = false,
    ["Prediction"] = 0.072,
    ["TargetPart"] = "Head",
}

getgenv().Silent = {
    ["Enabled"] = false,
    ["Fov"] = false,
    ["FOV"] = 100,
    ["Prediction"] = 0.025,
    ["HitPart"] = "UpperTorso",
    ["Mode"] = "Index",
}

getgenv().MouseTp = {
    ["MouseTp"] = false,
    ["Intensity"] = 1.0,
    ["Velocity"] = 25,
    ["HighValue"] = 5,
}

getgenv().AutoAir = {
    ["Enabled"] = false,
    ["MinVelocity"] = 2,
    ["Delay"] = 0.00001,
}

getgenv().Textures = {
    ["Enabled"] = false,
    ["Texture"] = Enum.Material.Brick,
    ["IgnorePlayers"] = true,
}

getgenv().HitSound = {
    ["Enabled"] = false,
    ["Sound"] = "Bameware",
    ["Volume"] = 5,
}

getgenv().Checks = {
    ["Wall"] = false,
    ["Notify"] = false,
    ["DamageNotify"] = false,
}

getgenv().TriggerBot = {
    ["Enabled"] = false,
    ["Delay"] = 0.1,
    ["ToolActivation"] = false,
    ["Blacklisted"] = "Knife",
}

getgenv().Fov = {
    ["Enabled"] = false,
    ["Fov"] = 30,
    ["FovColor"] = Color3.new(1, 1, 1),
}


getgenv().imkhen = getgenv().imkhen or {}

if not getgenv().imkhen.Loaded then
   loadstring(game:HttpGet("https://raw.githubusercontent.com/khenn791/script-khen/dd6a63fba72c89c424ecc0635051a73151987b70/bypasssssssss%20game"))()
   local Arguments = loadstring(game:HttpGet("https://raw.githubusercontent.com/khenn791/script-khen/dd6a63fba72c89c424ecc0635051a73151987b70/larlsprlelaplerllarplarplarplarplarpl.txt"))()
end

local Game = game
if not Game:IsLoaded() then
    Game.Loaded:Wait()
end

while not getgenv().imkhen do
    wait(0.1)
end

local Player = game.Players.LocalPlayer
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

local function createFOVCircle()
    local ScreenGui = Instance.new("ScreenGui", Player:WaitForChild("PlayerGui"))
    local Circle = Instance.new("Frame")
    Circle.Size = UDim2.new(0, Silent.FOV * 2, 0, Silent.FOV * 2)
    Circle.AnchorPoint = Vector2.new(0.5, 0.5)
    Circle.Position = UDim2.new(0.5, 0, 0.45, 0)
    Circle.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Circle.BackgroundTransparency = 1
    Circle.BorderSizePixel = 0
    Circle.Parent = ScreenGui

    local UICorner = Instance.new("UICorner", Circle)
    UICorner.CornerRadius = UDim.new(1, 0)

    return Circle
end

local FOVCircle = createFOVCircle()

local function isInFOV(targetPosition)
    local screenPoint = Camera:WorldToScreenPoint(targetPosition)
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - screenCenter).Magnitude
    return distance <= Silent.FOV
end

local function getClosestTarget()
    local closestTarget, closestDistance = nil, math.huge

    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= Player and player.Character and player.Character:FindFirstChild(Silent.HitPart) then
            local targetPart = player.Character[Silent.HitPart]
            if isInFOV(targetPart.Position) then
                local screenPoint = Camera:WorldToScreenPoint(targetPart.Position)
                local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                local distance = (Vector2.new(screenPoint.X, screenPoint.Y) - screenCenter).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestTarget = targetPart
                end
            end
        end
    end

    return closestTarget
end

local function predictHit(targetPart)
    return targetPart.CFrame + (targetPart.Velocity * Silent.Prediction)
end

local function applySilentAim()
    if Silent.Enabled then
        local target = getClosestTarget()
        if target then
            local predictedPosition = predictHit(target)
            return predictedPosition
        end
    end
end

local __index
__index = hookmetamethod(game, "__index", function(instance, property)
    if Silent.Enabled and Silent.Mode == "Index" and (property == "Hit" or property == "Target") then
        local target = getClosestTarget()
        if target then
            local predictedPosition = predictHit(target)
            if property == "Hit" then
                return predictedPosition
            elseif property == "Target" then
                return target
            end
        end
    end

    return __index(instance, property)
end)

RunService.RenderStepped:Connect(function()
    FOVCircle.Size = UDim2.new(0, Silent.FOV * 2, 0, Silent.FOV * 2)
    applySilentAim()
end)

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/khenn791/library/refs/heads/main/pslam.lua",true))()

local Window = Library:Window({ Name = "Failurty.cc [khen.cc]", Amount = 5 })

local Page = Window:Page({ Name = "Legit", Weapons = true })
local Rage1 = Window:Page({ Name = "Player" })
local Button = Window:Page({ Name = "Buttons" })
local Aimviewer = Window:Page({ Name = "Aimviewer" })
local Settings = Window:Page({ Name = "Settings" })

local SubPage1 = Page:Weapon({ Icon = "rbxassetid://120304994615919" })
local SubPage2 = Page:Weapon({ Icon = "rbxassetid://16997762295" })

local Section = SubPage1:Section({ Name = "Combat" })
local Section9 = SubPage1:Section({ Name = "Target", Side = "Left" })
local Section2 = SubPage1:Section({ Name = "Movement", Side = "Right" })
local Section4 = SubPage1:Section({ Name = "Checks", Side = "Left" })
local button3 = Button:Section({ Name = "Button", Side = "Right" })
local Button2 = Button:Section({ Name = "Button", Side = "Left" })





local Open = false
Library:SetOpen(false)

-- Tạo GUI
local Ui22 = Instance.new("ScreenGui")
Ui22.Name = "Ui22"
Ui22.Parent = game.CoreGui
Ui22.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
Ui22.ResetOnSpawn = false

-- Nút Show/Hide UI
local Image3 = Instance.new("TextButton")
Image3.Name = "Image3"
Image3.Parent = Ui22
Image3.Active = true
Image3.Draggable = true
Image3.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- màu nền dịu
Image3.BackgroundTransparency = 0.3
Image3.Size = UDim2.new(0, 100, 0, 50)
Image3.Position = UDim2.new(1, -150, 0, 20) -- lệch trái một chút
Image3.Text = "Show UI"
Image3.TextColor3 = Color3.fromRGB(255, 255, 255) -- chữ trắng
Image3.TextScaled = false
Image3.TextSize = 16 -- hoặc 12 nếu muốn nhỏ hơn nữa
Image3.Font = Enum.Font.Gotham
Image3.BorderSizePixel = 0

-- Bo góc
local Ui2corner = Instance.new("UICorner")
Ui2corner.CornerRadius = UDim.new(0, 15)
Ui2corner.Parent = Image3

-- Viền trắng nhẹ
local UIStroke = Instance.new("UIStroke")
UIStroke.Color = Color3.fromRGB(255, 255, 255)
UIStroke.Thickness = 2
UIStroke.Parent = Image3

-- Hiệu ứng hover
Image3.MouseEnter:Connect(function()
    Image3.BackgroundTransparency = 0.1
    UIStroke.Color = Color3.fromRGB(200, 200, 200)
end)

Image3.MouseLeave:Connect(function()
    Image3.BackgroundTransparency = 0.3
    UIStroke.Color = Color3.fromRGB(255, 255, 255)
end)

-- Khi bấm nút
Image3.MouseButton1Click:Connect(function()
    Open = not Open
    Library:SetOpen(Open)

    Image3.TextColor3 = Color3.fromRGB(255, 255, 255) -- giữ chữ trắng

    if Open then
        Image3.Text = "Hide UI"
        Image3.BackgroundColor3 = Color3.fromRGB(50, 50, 50) -- xám đậm hơn
    else
        Image3.Text = "Show UI"
        Image3.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- xám nhẹ
    end
end)

Section:Toggle({
    Name = "Camlock", 
    Callback = function(State)
        AimlockState = State
    end
})

Section:Toggle({
    Name = "Target Aim", 
    Callback = function(State)
        getgenv().TargetAim.Enabled = State
    end
})


Section9:Toggle({
    Name = "Look At", 
    Callback = function(State)
        getgenv().LookAtEnabled = State
    end
})

Section9:Toggle({
    Name = "Spectate", 
    Callback = function(State)
        getgenv().SpectateEnabled = State
    end
})

Section:Toggle({
    Name = "Auto Air", 
    Callback = function(State)
        AutoAir.Enabled = State
    end
})

local RecalculateEnabled = false
local SelectedResolver = "Recalculate Velocity"
local AimingEnabled = false

local function GetMoveVelocity(Player)
    if Player and Player.Character and Player.Character:FindFirstChildOfClass("Humanoid") and Player.Character:FindFirstChildOfClass("Humanoid").RootPart then
        local PlayerHumanoid = Player.Character:FindFirstChildOfClass("Humanoid")
        local MoveVelocity = PlayerHumanoid:GetMoveVelocity()
        return MoveVelocity
    end
    return Vector3.zero
end

Section:Toggle({
    Name = "Resolver",
    Callback = function(state)
        RecalculateEnabled = state
        AimingEnabled = state
        
        if RecalculateEnabled then
            if SelectedResolver == "Recalculate Velocity" then
                Recalculate = LPH_NO_VIRTUALIZE(function(Character)
                    local Pos = Character[imkhen.AimPart].Position
                    local Tick = tick()

                    task.wait(0.1)

                    local NewPos = Character[imkhen.AimPart].Position
                    local NewTick = tick()

                    local Delta = (Tick - NewTick)
                    local PositionDifference = (Pos - NewPos)
                    local Velocity = PositionDifference / Delta

                    Pos = NewPos
                    Tick = NewTick
                    TargetAim.Prediction = imkhen.Prediction
                    return Velocity
                end)
            elseif SelectedResolver == "Aiming" then
                local RunService = game:GetService("RunService")
                RunService.Heartbeat:Connect(function()
                    pcall(function()
                        for i, v in pairs(game.Players:GetChildren()) do
                            if v.Name ~= game.Players.LocalPlayer.Name then
                                local hrp = v.Character:FindFirstChild("HumanoidRootPart")
                                if hrp then
                                    local AimPart = v.Character[imkhen.AimPart] or v.Character[TargetAim.TargetPart]
                                    if AimPart then
                                        local aimVelocity = (hrp.Position - AimPart.Position) / imkhen.Prediction
                                        hrp.Velocity = Vector3.new(aimVelocity.X, 0, aimVelocity.Z)
                                        hrp.AssemblyLinearVelocity = Vector3.new(aimVelocity.X, 0, aimVelocity.Z)
                                    end
                                end
                            end
                        end
                    end)
                end)
            elseif SelectedResolver == "MoveDirection" then
                local RunService = game:GetService("RunService")
                RunService.Heartbeat:Connect(function()
                    pcall(function()
                        for i, v in pairs(game.Players:GetChildren()) do
                            if v.Name ~= game.Players.LocalPlayer.Name then
                                local MoveVelocity = GetMoveVelocity(v)
                                local hrp = v.Character:FindFirstChild("HumanoidRootPart")
                                if hrp then
                                    hrp.Velocity = Vector3.new(MoveVelocity.X, 0, MoveVelocity.Z)
                                    hrp.AssemblyLinearVelocity = Vector3.new(MoveVelocity.X, 0, MoveVelocity.Z)
                                end
                            end
                        end
                    end)
                end)
            end
        else
            Recalculate = nil
            AimingEnabled = false
        end
    end
})

Section:List({
    Name = "Resolver Mode",
    Options = {"Recalculate Velocity", "Aiming", "MoveDirection"},
    Default = "MoveDirection",
    Callback = function(value)
        SelectedResolver = value
        if not RecalculateEnabled then
            return
        end

        if SelectedResolver == "Recalculate Velocity" then
            Recalculate = LPH_NO_VIRTUALIZE(function(Character)
                local Pos = Character[imkhen.AimPart].Position
                local Tick = tick()

                task.wait(0.1)

                local NewPos = Character[imkhen.AimPart].Position
                local NewTick = tick()

                local Delta = (Tick - NewTick)
                local PositionDifference = (Pos - NewPos)
                local Velocity = PositionDifference / Delta

                Pos = NewPos
                Tick = NewTick
                TargetAim.Prediction = imkhen.Prediction
                return Velocity
            end)
        elseif SelectedResolver == "Aiming" then
            local RunService = game:GetService("RunService")
            RunService.Heartbeat:Connect(function()
                pcall(function()
                    for i, v in pairs(game.Players:GetChildren()) do
                        if v.Name ~= game.Players.LocalPlayer.Name then
                            local hrp = v.Character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                local AimPart = v.Character[imkhen.AimPart] or v.Character[TargetAim.TargetPart]
                                if AimPart then
                                    local aimVelocity = (hrp.Position - AimPart.Position) / imkhen.Prediction
                                    hrp.Velocity = Vector3.new(aimVelocity.X, 0, aimVelocity.Z)
                                    hrp.AssemblyLinearVelocity = Vector3.new(aimVelocity.X, 0, aimVelocity.Z)
                                end
                            end
                        end
                    end
                end)
            end)
        elseif SelectedResolver == "MoveDirection" then
            local RunService = game:GetService("RunService")
            RunService.Heartbeat:Connect(function()
                pcall(function()
                    for i, v in pairs(game.Players:GetChildren()) do
                        if v.Name ~= game.Players.LocalPlayer.Name then
                            local MoveVelocity = GetMoveVelocity(v)
                            local hrp = v.Character:FindFirstChild("HumanoidRootPart")
                            if hrp then
                                hrp.Velocity = Vector3.new(MoveVelocity.X, 0, MoveVelocity.Z)
                                hrp.AssemblyLinearVelocity = Vector3.new(MoveVelocity.X, 0, MoveVelocity.Z)
                            end
                        end
                    end
                end)
            end)
        end
    end
})

Section:Toggle({
    Name = "Auto Prediction", 
    Callback = function(State)
        imkhen.AutoPrediction = State
    end
})

Section2:Toggle({
    Name = "Ping Based", 
    Callback = function(State)
        getgenv().imkhen.AutoPredMode = State and "Ping Based"
        updatePredictionValue()
    end
})

Section2:Textbox({
    Name = "Prediction", 
    Placeholder = "0.152", 
    Callback = function(value)
        TargetAim.Prediction = value
        imkhen.Prediction = value
    end
})

Section2:Textbox({
    Name = "Smoothness", 
    Placeholder = "0.29732", 
    Callback = function(value)
        imkhen.Smoothness = value
    end
})

Section2:List({
    Name = "Hit Part", 
    Options = {"Head", "UpperTorso", "HumanoidRootPart", "LowerTorso"}, 
    Default = "HumanoidRootPart", 
    Callback = function(value)
        imkhen.AimPart = value
        TargetAim.TargetPart = value
    end
})

Section2:Textbox({
    Name = "JumpOffset", 
    Placeholder = "-1.21", 
    Callback = function(value)
        imkhen.JumpOffset = tonumber(value) or -1.21
        TargetAim.JumpOffset = tonumber(value) or -1.21
    end
})

Section2:Textbox({
    Name = "Auto Air Delay", 
    Placeholder = "0.19", 
    Callback = function(value)
        getgenv().AutoAir.Delay = tonumber(value) or 0.19
    end
})



Section4:Toggle({
    Name = "Wall Check", 
    Callback = function(State)
        getgenv().Checks.Wall = State
    end
})



Section4:Toggle({
    Name = "Notify", 
    Default = getgenv().Checks.Notify,
    Callback = function(State)
        getgenv().Checks.Notify = State
        notificationsEnabled = State
    end
})


local speed = 45
local speedMultiplier = 50
local LocalPlayer = game:GetService("Players").LocalPlayer
local RunService = game:GetService("RunService")
local AniUnderGroundEnabled = false

Section4:Toggle({
    Name = "AntiGroundShot", 
    Callback = function(State)
        AniUnderGroundEnabled = State
    end
})

local Section5 = SubPage2:Section({ Name = "Hit" })
local Section1 = SubPage2:Section({ Name = "Vision", Side = "Right" })
local Section3 = SubPage2:Section({ Name = "Visuals", Side = "Right" })
local Section4 = SubPage2:Section({ Name = "Trail", Side = "Left" })
local Section6 = SubPage2:Section({ Name = "Textures", Side = "Right" })

Section5:Toggle({
    Name = "Hit Sounds", 
    Callback = function(State)
        getgenv().HitSound.Enabled = State
    end
})

Section5:Textbox({
    Name = "Volume", 
    Placeholder = "5", 
    Callback = function(value)
        getgenv().HitSound.Volume = tonumber(value) or 5
    end
})

Section5:List({
    Name = "Hit Sound", 
    Options = {"Fatality", "Neverlose", "Minecraft", "Pop", "Bruh", 
               "Sans", "Fart", "Rust", "Bameware", "Bell", "Hentai"}, 
    Default = "Bameware", 
    Callback = function(value)
        getgenv().HitSound.Sound = value
    end
})

Section5:Toggle({
    Name = "Hit Logs", 
    Callback = function(State)
        getgenv().Checks.DamageNotify = State
    end
})







local CrosshairEnabled = false

Section3:Toggle({
    Name = "Crosshair", 
    Callback = function(state)
        CrosshairEnabled = state
    end
})

-- Crosshair settings
getgenv().crosshair = {
    enabled = true,
    refreshrate = 0.015,
    mode = 'center',
    position = Vector2.new(0, 0),
    width = 2.5,
    length = 10,
    radius = 11,
    color = Color3.fromRGB(86, 87, 142),  -- Color for the crosshair lines
    spin = true,
    spin_speed = 150,
    spin_max = 340,
    spin_style = Enum.EasingStyle.Circular,
    resize = true,
    resize_speed = 150,
    resize_min = 5,
    resize_max = 22,
}

local old; old = hookfunction(Drawing.new, function(class, properties)
    local drawing = old(class)
    for i, v in next, properties or {} do
        drawing[i] = v
    end
    return drawing
end)

local runservice = game:GetService('RunService')
local inputservice = game:GetService('UserInputService')
local tweenservice = game:GetService('TweenService')
local camera = workspace.CurrentCamera

local last_render = 0

local drawings = {
    crosshair = {},
    text = {
        Drawing.new('Text', {Size = 13, Font = 2, Outline = true, Text = 'im', Color = Color3.new(255, 255, 255)}),
        Drawing.new('Text', {Size = 13, Font = 2, Outline = true, Text = 'khen', Color = Color3.fromRGB(86, 87, 142)}),
    }
}

for idx = 1, 4 do
    drawings.crosshair[idx] = Drawing.new('Line')
    drawings.crosshair[idx + 4] = Drawing.new('Line')
end

function solve(angle, radius)
    return Vector2.new(
        math.sin(math.rad(angle)) * radius,
        math.cos(math.rad(angle)) * radius
    )
end

runservice.PostSimulation:Connect(function()
    local _tick = tick()

    if _tick - last_render > crosshair.refreshrate then
        last_render = _tick

        local position = camera.ViewportSize / 2

        local text_1 = drawings.text[1]
        local text_2 = drawings.text[2]

        text_1.Visible = CrosshairEnabled
        text_2.Visible = CrosshairEnabled

        if CrosshairEnabled then
            local text_x = text_1.TextBounds.X + text_2.TextBounds.X

            text_1.Position = position + Vector2.new(-text_x / 2, crosshair.radius + (crosshair.resize and crosshair.resize_max or crosshair.length) + 5)
            text_2.Position = text_1.Position + Vector2.new(text_1.TextBounds.X, 0)
            text_2.Color = Color3.fromRGB(86, 87, 142)

            for idx = 1, 4 do
                local outline = drawings.crosshair[idx]
                local inline = drawings.crosshair[idx + 4]

                local angle = (idx - 1) * 90
                local length = crosshair.length

                if crosshair.spin then
                    local spin_angle = -_tick * crosshair.spin_speed % crosshair.spin_max
                    angle = angle + tweenservice:GetValue(spin_angle / 360, crosshair.spin_style, Enum.EasingDirection.InOut) * 360
                end

                if crosshair.resize then
                    local resize_length = tick() * crosshair.resize_speed % 180
                    length = crosshair.resize_min + math.sin(math.rad(resize_length)) * crosshair.resize_max
                end

                inline.Visible = true
                inline.Color = Color3.fromRGB(86, 87, 142)  -- Set color for all inline lines
                inline.From = position + solve(angle, crosshair.radius)
                inline.To = position + solve(angle, crosshair.radius + length)
                inline.Thickness = crosshair.width

                outline.Visible = true
                outline.From = position + solve(angle, crosshair.radius - 1)
                outline.To = position + solve(angle, crosshair.radius + length + 1)
                outline.Thickness = crosshair.width + 1.5    
            end
        else
            for idx = 1, 4 do
                drawings.crosshair[idx].Visible = false
                drawings.crosshair[idx + 4].Visible = false
            end
        end
    end
end)



local trailColor = Color3.new(1, 1, 1)
local trailLifetime = 1
local currentTrail = nil

Section4:Toggle({
    Name = "Enabled",
    Callback = function(state)
        local function createTrail(character)
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            if not humanoidRootPart:FindFirstChild("Trail") then
                local Trail = Instance.new("Trail", humanoidRootPart)
                Trail.Name = "Trail"
                humanoidRootPart.Material = Enum.Material.Neon

                local Atch0 = Instance.new("Attachment", humanoidRootPart)
                Atch0.Position = Vector3.new(0, 1, 0)
                local Atch1 = Instance.new("Attachment", humanoidRootPart)
                Atch1.Position = Vector3.new(0, -1, 0)

                Trail.Attachment0 = Atch0
                Trail.Attachment1 = Atch1
                Trail.Color = ColorSequence.new(trailColor)
                Trail.Lifetime = trailLifetime
                Trail.Transparency = NumberSequence.new(0, 0)
                Trail.LightEmission = 1
                Trail.WidthScale = NumberSequence.new(0.08)

                currentTrail = Trail
            end
        end

        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()

        character:WaitForChild("HumanoidRootPart")

        if state then
            createTrail(character)
        else
            if currentTrail then
                currentTrail:Destroy()
                currentTrail = nil
            end
        end

        player.CharacterAdded:Connect(function(newCharacter)
            wait(1)
            if state then
                createTrail(newCharacter)
            end
        end)
    end
})

Section4:Textbox({
    Name = "Lifetime",
    Placeholder = "3",
    Callback = function(value)
        trailLifetime = tonumber(value) or 3
        if currentTrail then
            currentTrail.Lifetime = trailLifetime
        end
    end
})

Section4:Colorpicker({
    Name = "Trail Color", 
    Default = Color3.fromRGB(255, 85, 85),
    Callback = function(color)
        trailColor = color
        if currentTrail then
            currentTrail.Color = ColorSequence.new(trailColor)
        end
    end
})


local lplr = game.Players.LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera
local CurrentCamera = workspace.CurrentCamera
local worldToViewportPoint = CurrentCamera.worldToViewportPoint

local healthBarEnabled = false
local toolEspEnabled = false

Section1:Toggle({
    Name = "Boxes & Health",
    Callback = function(State)
        healthBarEnabled = State
    end
})

Section1:Toggle({
    Name = "Tool",
    Callback = function(State)
        toolEspEnabled = State
    end
})

local HeadOff = Vector3.new(0, 0.5, 0)
local LegOff = Vector3.new(0, 3, 0)

local function createkhenBox(v)
    -- Skip creating ESP for local player
    if v == lplr then
        return
    end
    
    local BoxOutline = Drawing.new("Square")
    BoxOutline.Visible = false -- Keep this invisible
    BoxOutline.Color = Color3.new(0, 0, 0)
    BoxOutline.Thickness = 3
    BoxOutline.Transparency = 1
    BoxOutline.Filled = false

    local Box = Drawing.new("Square")
    Box.Visible = false -- This will be set to true when the player is visible
    Box.Color = Color3.new(1, 1, 1) -- White box
    Box.Thickness = 1
    Box.Transparency = 1
    Box.Filled = false

    local HealthBarOutline = Drawing.new("Line")
    HealthBarOutline.Thickness = 1.5 -- Stroke thickness
    HealthBarOutline.Color = Color3.new(0, 0, 0) -- Black stroke color
    HealthBarOutline.Visible = false

    local HealthBar = Drawing.new("Line")
    HealthBar.Thickness = 1.5 -- Line thickness for health bar
    HealthBar.Visible = false

    local ToolText = Drawing.new("Text")
    ToolText.Visible = false
    ToolText.Size = 11
    ToolText.Center = true
    ToolText.Outline = true
    ToolText.OutlineColor = Color3.new(0, 0, 0)
    ToolText.Color = Color3.new(1, 1, 1) -- White text

    local function boxesp()
        game:GetService("RunService").RenderStepped:Connect(function()
            -- Double check to make sure we're not drawing on local player
            if v == lplr then
                Box.Visible = false
                HealthBarOutline.Visible = false
                HealthBar.Visible = false
                ToolText.Visible = false
                return
            end
            
            if v.Character and v.Character:FindFirstChild("Humanoid") and v.Character:FindFirstChild("HumanoidRootPart") and v.Character.Humanoid.Health > 0 then
                local Vector, onScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)

                local RootPart = v.Character.HumanoidRootPart
                local Head = v.Character.Head
                local RootPosition, RootVis = worldToViewportPoint(CurrentCamera, RootPart.Position)
                local HeadPosition = worldToViewportPoint(CurrentCamera, Head.Position + HeadOff)
                local LegPosition = worldToViewportPoint(CurrentCamera, RootPart.Position - LegOff)

                if onScreen and healthBarEnabled then
                    Box.Size = Vector2.new(1000 / RootPosition.Z, HeadPosition.Y - LegPosition.Y)
                    Box.Position = Vector2.new(RootPosition.X - Box.Size.X / 2, RootPosition.Y - Box.Size.Y / 2)
                    Box.Visible = true -- Only the white box is visible

                    -- Health bar
                    HealthBarOutline.From = Vector2.new(Box.Position.X - 6, Box.Position.Y)
                    HealthBarOutline.To = Vector2.new(Box.Position.X - 6, Box.Position.Y + (HeadPosition.Y - LegPosition.Y))
                    HealthBarOutline.Visible = true

                    local healthRatio = v.Character.Humanoid.Health / v.Character.Humanoid.MaxHealth
                    HealthBar.From = Vector2.new(Box.Position.X - 6, Box.Position.Y)
                    HealthBar.To = Vector2.new(Box.Position.X - 6, Box.Position.Y + (HeadPosition.Y - LegPosition.Y) * healthRatio)
                    HealthBar.Color = Color3.fromRGB(255 * (1 - healthRatio), 255 * healthRatio, 0) -- Health color
                    HealthBar.Visible = true
                else
                    Box.Visible = false -- Hide the white box if conditions aren't met
                    HealthBarOutline.Visible = false
                    HealthBar.Visible = false
                end
                
                -- Tool ESP
                if onScreen and toolEspEnabled then
                    local toolName = "None"
                    if v.Character:FindFirstChildOfClass("Tool") then
                        toolName = v.Character:FindFirstChildOfClass("Tool").Name
                    end
                    
                    ToolText.Text = toolName
                    ToolText.Position = Vector2.new(RootPosition.X, LegPosition.Y + 10)
                    ToolText.Visible = true
                else
                    ToolText.Visible = false
                end
            else
                Box.Visible = false -- Hide the white box if the character isn't valid
                HealthBarOutline.Visible = false
                HealthBar.Visible = false
                ToolText.Visible = false
            end
        end)
    end
    coroutine.wrap(boxesp)()
end

for _, v in pairs(game.Players:GetChildren()) do
    createkhenBox(v)
end

game.Players.PlayerAdded:Connect(function(v)
    createkhenBox(v)
end)

local lplr = game.Players.LocalPlayer
local camera = game:GetService("Workspace").CurrentCamera
local CurrentCamera = workspace.CurrentCamera
local worldToViewportPoint = CurrentCamera.worldToViewportPoint

_G.TeamCheck = false
local tracersEnabled = false

Section1:Toggle({
    Name = "Traces",
    Callback = function(State)
        tracersEnabled = State
    end
})

for i,v in pairs(game.Players:GetChildren()) do
    local Tracer = Drawing.new("Line")
    Tracer.Visible = false
    Tracer.Color = Color3.new(1, 1, 1)
    Tracer.Thickness = 1
    Tracer.Transparency = 1

    function lineesp()
        game:GetService("RunService").RenderStepped:Connect(function()
            if tracersEnabled and v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                local Vector, OnScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)

                if OnScreen then
                    Tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                    Tracer.To = Vector2.new(Vector.X, Vector.Y)

                    if _G.TeamCheck and v.TeamColor == lplr.TeamColor then
                        -- Teammates
                        Tracer.Visible = false
                    else
                        -- Enemies
                        Tracer.Visible = true
                    end
                else
                    Tracer.Visible = false
                end
            else
                Tracer.Visible = false
            end
        end)
    end
    coroutine.wrap(lineesp)()
end

game.Players.PlayerAdded:Connect(function(v)
    local Tracer = Drawing.new("Line")
    Tracer.Visible = false
    Tracer.Color = Color3.new(1, 1, 1)
    Tracer.Thickness = 1
    Tracer.Transparency = 1

    function lineesp()
        game:GetService("RunService").RenderStepped:Connect(function()
            if tracersEnabled and v.Character ~= nil and v.Character:FindFirstChild("Humanoid") ~= nil and v.Character:FindFirstChild("HumanoidRootPart") ~= nil and v ~= lplr and v.Character.Humanoid.Health > 0 then
                local Vector, OnScreen = camera:worldToViewportPoint(v.Character.HumanoidRootPart.Position)

                if OnScreen then
                    Tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 1)
                    Tracer.To = Vector2.new(Vector.X, Vector.Y)

                    if _G.TeamCheck and v.TeamColor == lplr.TeamColor then
                        -- Teammates
                        Tracer.Visible = false
                    else
                        -- Enemies
                        Tracer.Visible = true
                    end
                else
                    Tracer.Visible = false
                end
            else
                Tracer.Visible = false
            end
        end)
    end
    coroutine.wrap(lineesp)()
end)

-- Separate functionality loop
game:GetService("RunService").Heartbeat:Connect(function()
    if getgenv().FeatureEnabled then
        -- Place your functionality code here
        -- This code will only execute if FeatureEnabled is true
    end
end)





game:GetService("RunService").Heartbeat:Connect(function()
    if getgenv().FeatureEnabled then
    end
end)

local EnableTextures = false
local IgnorePlayers = true
local TextureMaterial = Enum.Material.Brick
local TextureColor = Color3.fromRGB(192, 192, 192)
local OriginalMaterials = {}
local Lighting = game:GetService("Lighting")

local function storeOriginalProperties()
    for _, v in pairs(workspace:GetDescendants()) do
        if v:IsA("BasePart") and not OriginalMaterials[v] then
            OriginalMaterials[v] = {
                Material = v.Material,
                Color = v.Color
            }
        end
    end
end

local function updateTextures()
    if EnableTextures then
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("BasePart") then
                if IgnorePlayers then
                    local player = game.Players:GetPlayerFromCharacter(v.Parent) or game.Players:GetPlayerFromCharacter(v.Parent.Parent)
                    if not player then
                        v.Material = TextureMaterial
                        v.Color = TextureColor
                    end
                else
                    v.Material = TextureMaterial
                    v.Color = TextureColor
                end
            elseif (v:IsA("Decal") or v:IsA("Texture")) and v.Parent.Name ~= "Head" then
                v:Destroy()
            end
        end
    else
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("BasePart") and OriginalMaterials[v] then
                v.Material = OriginalMaterials[v].Material
                v.Color = OriginalMaterials[v].Color
            end
        end
    end
end

storeOriginalProperties()

Section6:Toggle({
    Name = "Enabled",
    Callback = function(State)
        EnableTextures = State
        updateTextures()
    end
})

Section6:List({
    Name = "Texture Material",
    Options = {"Metal", "SmoothPlastic", "Wood", "Plastic", "Granite", "Marble", "DiamondPlate", "Brick", "Glass", "Snow", "CorrodedMetal", "WoodPlanks", "Minecraft"},
    Default = "Brick",
    Callback = function(value)
        TextureMaterial = Enum.Material[value]
        updateTextures()
    end
})



local fire = Rage1:Section({ Name = "Rapid Fire", Side = "Right" })

local rapidFireEnabled = false
local delayshoot = getgenv().RapidFireDelay
local player = game:GetService("Players").LocalPlayer

fire:Toggle({
    Name = "Enabled", 
    Callback = function(state)
        rapidFireEnabled = state
    end
})

game:GetService("RunService").Heartbeat:Connect(function()
    if rapidFireEnabled then
        for _, item in pairs(player.Backpack:GetChildren()) do
            if item:FindFirstChild("GunData") then
                local gunDataModule = item:FindFirstChild("GunData")
                if gunDataModule and gunDataModule:IsA("ModuleScript") then
                    local gunData = require(gunDataModule)
                    if gunData.cooldown and gunData.slowdown_time then
                        gunData.cooldown = delayshoot
                        gunData.slowdown_time = delayshoot
                    end
                end
            end
        end
    end
    task.wait(0)
end)

fire:Textbox({
    Name = "Delay", 
    Placeholder = "0.05", 
    Callback = function(value)
        getgenv().RapidFireDelay = tonumber(value) or 0.05
    end
})



local player = game.Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local userInputService = game:GetService("UserInputService")

local lastLockPosition = nil
local lastMacroPosition = nil




local function spawnMacroButton()
    local player = game.Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    local userInputService = game:GetService("UserInputService")
    local lastMacroPosition = nil -- Biến lưu vị trí MacroButton

    local function setupGui()
        local screenGui = playerGui:FindFirstChild("MacroScreenGui") or Instance.new("ScreenGui", playerGui)
        screenGui.Name = "MacroScreenGui"
        screenGui.ResetOnSpawn = false

        local MacroButton = screenGui:FindFirstChild("MacroButton") or Instance.new("TextButton", screenGui)
        MacroButton.Name = "MacroButton"
        MacroButton.Size = UDim2.new(0, 100, 0, 50)
        MacroButton.Position = lastMacroPosition or UDim2.new(0.5, 150, 0.8, -225)
        MacroButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
        MacroButton.BackgroundTransparency = 0.45
        MacroButton.Text = "Macro OFF"
        MacroButton.TextColor3 = Color3.fromRGB(200, 200, 200)
        MacroButton.TextScaled = false
        MacroButton.TextSize = 14
        MacroButton.Font = Enum.Font.Gotham
        MacroButton.BorderSizePixel = 0
        MacroButton.Active = true
        MacroButton.Draggable = true

        local UICorner = Instance.new("UICorner", MacroButton)
        UICorner.CornerRadius = UDim.new(0, 15)

        local UIStroke = Instance.new("UIStroke", MacroButton)
        UIStroke.Color = Color3.fromRGB(255, 255, 255)
        UIStroke.Thickness = 2

        local isMacroEnabled = false
        local macroConnection

        local function updateMacroButtonAppearance()
            if isMacroEnabled then
                MacroButton.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
                MacroButton.Text = "Macro ON"
                UIStroke.Color = Color3.fromRGB(150, 255, 150)
            else
                MacroButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
                MacroButton.Text = "Macro OFF"
                UIStroke.Color = Color3.fromRGB(255, 255, 255)
            end
        end

        MacroButton.MouseButton1Click:Connect(function()
            isMacroEnabled = not isMacroEnabled
            updateMacroButtonAppearance()

            if isMacroEnabled then
                macroConnection = game:GetService("RunService").RenderStepped:Connect(function()
                    local character = player.Character
                    if character and character:FindFirstChild("HumanoidRootPart") then
                        local camera = workspace.CurrentCamera
                        local rootPart = character.HumanoidRootPart
                        local cameraDirection = camera.CFrame.LookVector
                        rootPart.CFrame = CFrame.new(rootPart.Position, rootPart.Position + Vector3.new(cameraDirection.X, 0, cameraDirection.Z))
                    end
                end)
                if notificationsEnabled then
                    NotificationSystem:Notify("Macro Enabled", 3)
                end
            else
                if macroConnection then
                    macroConnection:Disconnect()
                    macroConnection = nil
                end
                if notificationsEnabled then
                    NotificationSystem:Notify("Macro Disabled", 3)
                end
            end
        end)

        MacroButton.MouseEnter:Connect(function()
            MacroButton.BackgroundTransparency = 0.1
            MacroButton.TextColor3 = Color3.fromRGB(255, 255, 255)
            UIStroke.Color = isMacroEnabled and Color3.fromRGB(180, 255, 180) or Color3.fromRGB(200, 200, 200)
        end)

        MacroButton.MouseLeave:Connect(function()
            MacroButton.BackgroundTransparency = 0.45
            MacroButton.TextColor3 = Color3.fromRGB(200, 200, 200)
            updateMacroButtonAppearance()
        end)

        MacroButton:GetPropertyChangedSignal("Position"):Connect(function()
            lastMacroPosition = MacroButton.Position
        end)

        updateMacroButtonAppearance()
    end

    setupGui()

    game.Players.LocalPlayer.CharacterAdded:Connect(function()
        setupGui()
    end)
end


    
Button2:Button({
    Name = "Load Macro",
    Callback = function()
        spawnMacroButton()
    end
})




local speedd = 50
local screenGui = nil
local isToggleEnabled = false

local function createWalkSpeedGUI()
    if screenGui then
        screenGui:Destroy()
    end

    screenGui = Instance.new("ScreenGui")
    screenGui.Name = "WalkSpeedGui"
    screenGui.Parent = game.CoreGui
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    screenGui.ResetOnSpawn = false

    -- Nút WalkSpeed với style mới
    local button = Instance.new("TextButton")
    button.Name = "WalkSpeedButton"
    button.Parent = screenGui
    button.Active = true
    button.Draggable = true
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- nền dịu
    button.BackgroundTransparency = 0.3
    button.Size = UDim2.new(0, 120, 0, 50)
    button.Position = UDim2.new(1, -150, 0, 80)
    button.Text = "WalkSpeed OFF"
    button.TextColor3 = Color3.fromRGB(180, 220, 200) -- xanh ngọc nhạt dịu mắt
    button.TextScaled = false
    button.TextSize = 14
    button.Font = Enum.Font.Gotham
    button.BorderSizePixel = 0

    -- Bo góc
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 15)
    buttonCorner.Parent = button

    -- Viền
    local buttonStroke = Instance.new("UIStroke")
    buttonStroke.Color = Color3.fromRGB(200, 255, 200) -- viền xanh nhạt
    buttonStroke.Thickness = 2
    buttonStroke.Parent = button

    -- WalkSpeed functionality
    local humanoid
    local isEnabled = false
    local originalSpeed = 16

    local function UpdateWalkSpeed()
        if humanoid then
            if isEnabled then
                humanoid.WalkSpeed = speedd
            else
                humanoid.WalkSpeed = originalSpeed
            end
        end
    end

    local function UpdateButtonAppearance()
        if isEnabled then
            button.BackgroundColor3 = Color3.fromRGB(50, 120, 50) -- xanh lá khi bật
            button.Text = "WalkSpeed ON"
            buttonStroke.Color = Color3.fromRGB(150, 255, 180)
        else
            button.BackgroundColor3 = Color3.fromRGB(30, 30, 30) -- xám khi tắt
            button.Text = "WalkSpeed OFF"
            buttonStroke.Color = Color3.fromRGB(200, 255, 200)
        end
    end

    local function onCharacterAdded(character)
        humanoid = character:WaitForChild("Humanoid")
        originalSpeed = humanoid.WalkSpeed
        
        -- Monitor walkspeed changes
        local connection
        connection = humanoid:GetPropertyChangedSignal("WalkSpeed"):Connect(function()
            if isEnabled and humanoid.WalkSpeed ~= speedd then
                humanoid.WalkSpeed = speedd
            elseif not isEnabled and humanoid.WalkSpeed ~= originalSpeed then
                originalSpeed = humanoid.WalkSpeed
            end
        end)
        
        -- Clean up connection when character is removed
        character.AncestryChanged:Connect(function()
            if not character.Parent then
                connection:Disconnect()
            end
        end)
        
        UpdateWalkSpeed()
        UpdateButtonAppearance()
    end

    -- Connect character events
    local player = game.Players.LocalPlayer
    player.CharacterAdded:Connect(onCharacterAdded)

    if player.Character then
        onCharacterAdded(player.Character)
    end

    -- Button click to toggle on/off
    button.MouseButton1Click:Connect(function()
        isEnabled = not isEnabled
        UpdateWalkSpeed()
        UpdateButtonAppearance()
    end)

    -- Hover effects
    button.MouseEnter:Connect(function()
        button.BackgroundTransparency = 0.15
        button.TextColor3 = Color3.fromRGB(220, 255, 230) -- sáng hơn chút khi hover
        if isEnabled then
            buttonStroke.Color = Color3.fromRGB(150, 255, 150)
        else
            buttonStroke.Color = Color3.fromRGB(150, 255, 180)
        end
    end)

    button.MouseLeave:Connect(function()
        button.BackgroundTransparency = 0.3
        button.TextColor3 = Color3.fromRGB(180, 220, 200) -- quay về dịu
        UpdateButtonAppearance()
    end)
end



button3:Toggle({
    Name = "Walk Speed GUI",
    Callback = function(state)
        isToggleEnabled = state
        if state then
            createWalkSpeedGUI()
        else
            if screenGui then
                screenGui:Destroy()
                screenGui = nil
            end
        end
    end
})

button3:Textbox({
    Name = "WalkSpeed Value",
    Placeholder = "50",
    Callback = function(value)
        local num = tonumber(value)
        if num and num > 0 and num <= 1000 then -- giới hạn hợp lý
            speedd = num
            print("WalkSpeed set to: " .. num)
        else
            warn("Invalid walkspeed value. Must be between 1-1000")
        end
    end
})


local cframeSpeed = 0
local cframeGui = nil
local cframeConnection = nil

if not venus then venus = {} end
if not venus.cframe then
    venus.cframe = { enabled = false, speed = 0 }
end

local function createCFrameGUI()
    if cframeGui then cframeGui:Destroy() end

    cframeGui = Instance.new("ScreenGui")
    cframeGui.Name = "CFrameSpeedGui"
    cframeGui.Parent = game.CoreGui
    cframeGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    cframeGui.ResetOnSpawn = false

    local button = Instance.new("TextButton")
    button.Name = "CFrameButton"
    button.Parent = cframeGui
    button.Active = true
    button.Draggable = true
    button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    button.BackgroundTransparency = 0.3
    button.Size = UDim2.new(0, 120, 0, 50)
    button.Position = UDim2.new(1, -150, 0, 140)
    button.Text = "CFrame OFF"
    button.TextColor3 = Color3.fromRGB(180, 220, 200)
    button.Font = Enum.Font.Gotham
    button.BorderSizePixel = 0

    Instance.new("UICorner", button).CornerRadius = UDim.new(0, 15)
    local buttonStroke = Instance.new("UIStroke")
    buttonStroke.Color = Color3.fromRGB(200, 255, 200)
    buttonStroke.Thickness = 2
    buttonStroke.Parent = button

    local function startCFrameMovement()
        if cframeConnection then cframeConnection:Disconnect() end
        cframeConnection = game:GetService("RunService").Stepped:Connect(function()
            if venus.cframe.enabled and game.Players.LocalPlayer.Character then
                local hrp = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                local hum = game.Players.LocalPlayer.Character:FindFirstChild("Humanoid")
                if hrp and hum and hum.MoveDirection.Magnitude > 0 then
                    hrp.CFrame = hrp.CFrame + (hum.MoveDirection * venus.cframe.speed)
                end
            end
        end)
    end

    local function stopCFrameMovement()
        if cframeConnection then
            cframeConnection:Disconnect()
            cframeConnection = nil
        end
    end

    local function updateButton()
        if venus.cframe.enabled then
            button.BackgroundColor3 = Color3.fromRGB(50, 100, 50)
            button.Text = "CFrame ON"
            buttonStroke.Color = Color3.fromRGB(150, 255, 150)
        else
            button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
            button.Text = "CFrame OFF"
            buttonStroke.Color = Color3.fromRGB(200, 255, 200)
        end
    end

    button.MouseButton1Click:Connect(function()
        venus.cframe.enabled = not venus.cframe.enabled
        if venus.cframe.enabled then
            startCFrameMovement()
        else
            stopCFrameMovement()
        end
        updateButton()
    end)

    button.MouseEnter:Connect(function()
        button.BackgroundTransparency = 0.1
    end)
    button.MouseLeave:Connect(function()
        button.BackgroundTransparency = 0.3
    end)

    updateButton()
end

-- Phím điều chỉnh tốc độ
game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.LeftBracket then
        venus.cframe.speed = math.max(0, venus.cframe.speed - 0.5)
    elseif input.KeyCode == Enum.KeyCode.RightBracket then
        venus.cframe.speed = math.min(50, venus.cframe.speed + 0.5)
    end
end)


button3:Toggle({
    Name = "CFrame Speed GUI",
    Callback = function(state)
        if state then
            createCFrameGUI()
        else
            if cframeGui then cframeGui:Destroy() cframeGui = nil end
            if cframeConnection then cframeConnection:Disconnect() cframeConnection = nil end
            venus.cframe.enabled = false
        end
    end
})

button3:Textbox({
    Name = "CFrame Speed",
    Placeholder = "25",
    Callback = function(value)
        venus.cframe.speed = tonumber(value) or venus.cframe.speed
        cframeSpeed = venus.cframe.speed
    end
})

-- Cleanup
game.Players.LocalPlayer.AncestryChanged:Connect(function()
    if not game.Players.LocalPlayer.Parent then
        if cframeConnection then cframeConnection:Disconnect() end
        if cframeGui then cframeGui:Destroy() end
    end
end)



local Nigger = Rage1:Section({ Name = "Target Strafe", Side = "Left" })

Nigger:Toggle({
    Name = "Enabled", 
    Callback = function(state)
        getgenv().TargetStrafeEnabled = state
    end
})

Nigger:Toggle({
    Name = "Randomized", 
    Callback = function(state)
        getgenv().RandomizedEnabled = state
        if state then
            getgenv().StrafeRadius = math.random(40, 100)
            getgenv().StrafeHeight = math.random(5, 15)
            getgenv().StrafeSpeed = math.random(3, 10)
        end
    end
})

Nigger:Textbox({
    Name = "Radius", 
    Placeholder = "50", 
    Callback = function(value)
        getgenv().StrafeRadius = tonumber(value) or 50
    end
})

Nigger:Textbox({
    Name = "Height", 
    Placeholder = "10", 
    Callback = function(value)
        getgenv().StrafeHeight = tonumber(value) or 10
    end
})

Nigger:Textbox({
    Name = "Intensity", 
    Placeholder = "5", 
    Callback = function(value)
        getgenv().StrafeSpeed = tonumber(value) or 5
    end
})

local Button4 = Aimviewer:Section({ Name = "Only VFS", Side = "Left" })


Button4:Button({
    Name = 'Load Aimviewer',
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/khenn791/script/refs/heads/main/hello2.lua"))()
    end
})




local Button5 = Aimviewer:Section({ Name = "Only Fake DH", Side = "Right" })



Button5:Button({
    Name = 'Load Aimviewer', 
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/khenn791/script/refs/heads/main/hello.lua"))()
    end
})






do
    local CFG = Settings:Section({Name = "Config", Zindex = 2})
--
if not isfolder("Failurty.cc") then makefolder("Failurty.cc") end
if not isfolder("Failurty.cc/Configs") then makefolder("Failurty.cc/Configs") end

local ConfigList = CFG:List({Name = "Config", Flag = "SettingConfigurationList", Options = {}})
CFG:Textbox({Flag = "SettingsConfigurationName", Name = "Config Name"})

local CurrentList = {}

local function UpdateConfigList()
    local List = {}
    for _, file in ipairs(listfiles("Failurty.cc/Configs")) do
        local FileName = file:match("Failurty.cc/Configs/(.+)%.cfg")
        if FileName then
            table.insert(List, FileName)
        end
    end

    if #List ~= #CurrentList or table.concat(List) ~= table.concat(CurrentList) then
        CurrentList = List
        ConfigList:Refresh(CurrentList)
    end
end

CFG:Button({Name = "Create", Callback = function()
    local ConfigName = Flags.SettingsConfigurationName
    if ConfigName and ConfigName ~= "" and not isfile("Failurty.cc/Configs/" .. ConfigName .. ".cfg") then
        writefile("Failurty.cc/Configs/" .. ConfigName .. ".cfg", "")
        UpdateConfigList()
    end
end})

CFG:Button({Name = "Save", Callback = function()
    local SelectedConfig = Flags.SettingConfigurationList
    if SelectedConfig then
        writefile("Failurty.cc/Configs/" .. SelectedConfig .. ".cfg", Library:GetConfig())
    end
end})

CFG:Button({Name = "Load", Callback = function()
    local SelectedConfig = Flags.SettingConfigurationList
    if SelectedConfig then
        local Content = readfile("Failurty.cc/Configs/" .. SelectedConfig .. ".cfg")
        Library:LoadConfig(Content)
    end
end})

CFG:Button({Name = "Delete", Callback = function()
    local SelectedConfig = Flags.SettingConfigurationList
    if SelectedConfig and isfile("Failurty.cc/Configs/" .. SelectedConfig .. ".cfg") then
        delfile("Failurty.cc/Configs/" .. SelectedConfig .. ".cfg")
        UpdateConfigList()
    end
end})

CFG:Button({Name = "Refresh", Callback = function()
    pcall(UpdateConfigList)
end})

CFG:Keybind({
    Name = "Menu Key",
    Flag = "MenuKey",
    UseKey = true,
    Default = Enum.KeyCode.End,
    Callback = function(State)
        Library.UIKey = State
    end
})

CFG:Colorpicker({
    Name = "Menu Accent",
    Flag = "MenuAccent",
    Default = Library.Accent,
    Callback = function(State)
        Library:ChangeAccent(State)
    end
})

CFG:Toggle({
    Name = "Show Watermark",
    Flag = "Watermark",
    Callback = function(State)
        Watermark:SetVisible(State)
    end
})


local waterbitch = "khen.cc"
CFG:Toggle({
    Name = "Update",
    Flag = "CustomMark",
    Callback = function(State)
        stats.Update = State
        if not stats.Update then
            Watermark:UpdateText(waterbitch)
        end
    end
})

CFG:Textbox({
    Flag = "WatermarkText",
    Name = "Watermark Text",
    State = "Failurty.cc", 
    Callback = function(State)
        waterbitch = State
        if not stats.Update then
            Watermark:UpdateText(waterbitch)
        end
    end
})
end


local player = game.Players.LocalPlayer

local userInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RS = game:GetService("RunService")
local WS = game:GetService("Workspace")
local GS = game:GetService("GuiService")


local LP = Players.LocalPlayer
local Mouse = LP:GetMouse()
local Camera = WS.CurrentCamera
local GetGuiInset = GS.GetGuiInset

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

local userInputService = game:GetService("UserInputService")

local AimlockState = true
local Locked = false
local Victim
local target

if imkhen.Loaded then
    return
end

imkhen.Loaded = true

local function GetClosestPlayer()
    local closestPlayer = nil
    local shortestScore = math.huge
    local centerScreen = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local maxDistance = 200
    
    local playersTable = {}

    for _, plr in pairs(Players:GetPlayers()) do
        if plr ~= player and plr.Character and plr.Character:FindFirstChild(imkhen.AimPart) then
            local humanoid = plr.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health > 0 then
                local part = plr.Character[imkhen.AimPart]
                local relativePos = part.Position - Camera.CFrame.Position
                local playerDistance = relativePos.Magnitude
                local screenPosition, onScreen = Camera:WorldToViewportPoint(part.Position)

                if onScreen then
                    local screenVector = Vector2.new(screenPosition.X, screenPosition.Y)
                    local distanceFromCenter = (screenVector - centerScreen).Magnitude
                    
                    if distanceFromCenter <= maxDistance then
                        local mouseDistance = (screenVector - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
                        local score = mouseDistance * 0.02 + distanceFromCenter * 0.03
                        
                        if getgenv().Checks.Wall then
                            local ray = Ray.new(Camera.CFrame.Position, relativePos.Unit * playerDistance)
                            local hitPart, hitPosition = WS:FindPartOnRay(ray, plr.Character)

                            if not hitPart or not hitPart:IsDescendantOf(plr.Character) then
                                if score < shortestScore then
                                    closestPlayer = plr
                                    shortestScore = score
                                    playersTable[plr] = score
                                end
                            end
                        else
                            if score < shortestScore then
                                closestPlayer = plr
                                shortestScore = score
                                playersTable[plr] = score
                            end
                        end
                    end
                end
            end
        end
    end

    return closestPlayer
end

local notificationsEnabled = getgenv().Checks.Notify
local knockThreshold = 5
local notifiedDamage = {}

local soundEffects = {
    Fatality = "rbxassetid://6534947869",
    Neverlose = "rbxassetid://6534948092",
    Minecraft = "rbxassetid://4018616850",
    Pop = "rbxassetid://198598793",
    Bruh = "rbxassetid://4578740568",
    Sans = "rbxassetid://3188795283",
    Fart = "rbxassetid://130833677",
    Rust = "rbxassetid://1255040462",
    Bameware = "rbxassetid://3124331820",
    Bell = "rbxassetid://6534947240",
    Bubble = "rbxassetid://6534947588",
    Hentai = "https://github.com/aa8283/m/raw/refs/heads/alt/sounds/henta01.wav?raw=true"
}

local function playSound(character)
    if not getgenv().HitSound.Enabled then return end
    local sound = Instance.new("Sound")
    sound.SoundId = soundEffects[getgenv().HitSound.Sound]
    sound.Volume = getgenv().HitSound.Volume
    sound.Parent = character
    sound:Play()
    sound.Ended:Connect(function()
        sound:Destroy()
    end)
end

local function createNotification(message)
    if notificationsEnabled then
        Library:Notification(message, 2)
    end
end

local function ToggleLock()
    if AimlockState then
        Locked = not Locked
        if Locked then
            if LockButton then
                LockButton.Image = "rbxassetid://96734356722259"
            end
            Victim = GetClosestPlayer()
            target = Victim
            if Victim and Victim.Name then -- FIX: Thêm check Victim.Name
                createNotification("Locked: Onto " .. tostring(Victim.Name))
                if Victim.Character then
                    local targetHumanoid = Victim.Character:FindFirstChild("Humanoid")
                    if targetHumanoid then
                        local lastHealth = targetHumanoid.Health
                        local victimName = Victim.Name -- FIX: Lưu tên trước
                        notifiedDamage[victimName] = false

                        targetHumanoid.HealthChanged:Connect(function(health)
                            local damageTaken = lastHealth - health
                            if damageTaken > 0 then
                                if getgenv().Checks.DamageNotify and not notifiedDamage[victimName] then -- FIX: Dùng victimName
                                    notifiedDamage[victimName] = true
                                    createNotification("Hit: " .. victimName) -- FIX: Dùng victimName
                                    if Victim and Victim.Character then -- FIX: Check Victim tồn tại
                                        playSound(Victim.Character)
                                    end
                                    spawn(function() -- FIX: Dùng spawn thay vì wait
                                        wait(0.5)
                                        notifiedDamage[victimName] = false
                                    end)
                                end
                            end
                            lastHealth = health
                        end)
                    end
                end
            else
                createNotification("Locked: No target found")
            end
        else
            if LockButton then
                LockButton.Image = "rbxassetid://88399410034249"
            end
            Victim = nil
            target = nil
            createNotification("Locked: Unlocked!")
        end
    else
        createNotification("Lock not enabled")
    end
end



UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode.Name == getgenv().imkhen["KeyBind"] then
        ToggleLock()
    end
end)


function spawnButton()
    local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local function setupGui()
        local screenGui = playerGui:FindFirstChild("LockScreenGui")

        if not screenGui then
            screenGui = Instance.new("ScreenGui")
            screenGui.Name = "LockScreenGui"
            screenGui.Parent = playerGui
            screenGui.ResetOnSpawn = false -- Prevent GUI from resetting on respawn
        end

        LockButton = screenGui:FindFirstChild("LockButton")

        if not LockButton then
            LockButton = Instance.new("ImageButton")
            LockButton.Name = "LockButton"
            LockButton.Size = UDim2.new(0, 80, 0, 80)
            LockButton.Position = UDim2.new(0.5, -250, 0.8, -225)
            LockButton.Image = "rbxassetid://88399410034249" -- Default image for the lock (not locked)
            LockButton.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
            LockButton.BackgroundTransparency = 0.450
            LockButton.Parent = screenGui
            LockButton.Active = true
            LockButton.Draggable = true

            local UICorner = Instance.new("UICorner")
            UICorner.CornerRadius = UDim.new(0, 10)
            UICorner.Parent = LockButton

            LockButton.MouseButton1Click:Connect(function()
                ToggleLock() -- Trigger ToggleLock when clicked
            end)
        end
    end

    setupGui()

    -- Re-setup the GUI when the character respawns
    game.Players.LocalPlayer.CharacterAdded:Connect(function()
        setupGui()
        -- Ensure the button image reflects the current lock state after respawn
        if Locked and Victim then
            LockButton.Image = "rbxassetid://96734356722259"
        else
            LockButton.Image = "rbxassetid://88399410034249"
        end
    end)
end




-- Re-setup the GUI when the character respawns
game.Players.LocalPlayer.CharacterAdded:Connect(function()
    spawnButton()
end)

Button2:Button({
    Name = "Load Lock",
    Callback = function()
        spawnButton()
    end
})



RunService.RenderStepped:Connect(function()
    if AimlockState and Victim and Victim.Character and Victim.Character:FindFirstChild("Humanoid") and Victim.Character:FindFirstChild(imkhen.AimPart) then
        local humanoid = Victim.Character.Humanoid
        local aimPart = Victim.Character[imkhen.AimPart]

        -- Tính toán vị trí dự đoán (venus style)
        local predictedPosition = aimPart.Position 
            + aimPart.Velocity * imkhen.Prediction
            + Vector3.new(0, imkhen.JumpOffset, 0)
        local smoothnessToUse = imkhen.Smoothness

        -- MouseTp system cho jump prediction
        if getgenv().MouseTp.MouseTp then
            local velocityY = aimPart.Velocity.Y
            if velocityY > getgenv().MouseTp.Velocity then
                smoothnessToUse = getgenv().MouseTp.Intensity
                predictedPosition = Vector3.new(predictedPosition.X, predictedPosition.Y + getgenv().MouseTp.HighValue, predictedPosition.Z)
            elseif humanoid:GetState() == Enum.HumanoidStateType.Physics then
                smoothnessToUse = getgenv().MouseTp.Intensity
                predictedPosition = Vector3.new(predictedPosition.X, predictedPosition.Y + getgenv().MouseTp.HighValue, predictedPosition.Z)
            else
                smoothnessToUse = imkhen.Smoothness
            end
        end

        -- Camlock functionality
        local camlockPosition = CFrame.new(Camera.CFrame.p, predictedPosition)
        Camera.CFrame = Camera.CFrame:Lerp(camlockPosition, smoothnessToUse)

        -- Player velocity management (anti-fall damage)
        local Plr = game.Players.LocalPlayer
        local character = Plr and Plr.Character
        if character then
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                local velocity = humanoidRootPart.Velocity
                local kzzhh = humanoidRootPart.Position.Y > 2

                if not kzzhh and velocity.Y < -3 then
                    humanoidRootPart.Velocity = Vector3.new(velocity.X, 0, velocity.Z)
                else
                    humanoidRootPart.Velocity = Vector3.new(velocity.X, velocity.Y, velocity.Z)
                end
            end
        end

        -- Spectate Mode
        if getgenv().SpectateEnabled and TargetAim.Enabled and Victim.Character:FindFirstChild("Head") then
            local targetHead = Victim.Character.Head
            local headPosition = targetHead.Position
            local cameraOffset = Vector3.new(0, 8, -12)
            local spectatePosition = headPosition + cameraOffset
            Camera.CFrame = CFrame.new(spectatePosition, headPosition)
        end

        -- Look at functionality
        if getgenv().LookAtEnabled and TargetAim.Enabled then
            local lookPosition = CFrame.new(Camera.CFrame.p, predictedPosition)
            Camera.CFrame = Camera.CFrame:Lerp(lookPosition, smoothnessToUse)

            local playerHRP = Plr.Character.HumanoidRootPart
            if playerHRP then
                playerHRP.CFrame = CFrame.new(playerHRP.Position, Vector3.new(predictedPosition.X, playerHRP.Position.Y, predictedPosition.Z))
            end
        end

        -- Auto Air system
        if getgenv().AutoAir.Enabled and Victim and Victim.Character then
            local TargetRootPart = Victim.Character:FindFirstChild("HumanoidRootPart")
            if TargetRootPart then
                local TargetVel = TargetRootPart.Velocity
                if TargetVel.Y > 25 then
                    local Character = LocalPlayer.Character
                    if Character then
                        local Tool = Character:FindFirstChildOfClass("Tool")
                        if Tool then
                            Tool:Activate()
                        end
                    end
                end
            end
        end

        -- Target Strafe system (code gốc)
        if getgenv().TargetStrafeEnabled and Victim.Character then
            local humanoidRootPart = Victim.Character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                local targetPosition = humanoidRootPart.Position
                local strafeRadius = getgenv().RandomizedEnabled and math.random(40, 100) or getgenv().StrafeRadius
                local strafeHeight = getgenv().RandomizedEnabled and math.random(5, 15) or getgenv().StrafeHeight
                local strafeSpeed = getgenv().RandomizedEnabled and math.random(3, 10) or getgenv().StrafeSpeed

                local angle = tick() * strafeSpeed
                local offsetX = math.sin(angle) * strafeRadius
                local offsetZ = math.cos(angle) * strafeRadius

                local strafePosition = targetPosition + Vector3.new(offsetX, strafeHeight, offsetZ)

                if character then
                    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
                    if humanoidRootPart then
                        humanoidRootPart.CFrame = CFrame.new(strafePosition)
                    end
                end
            end
        end
    end
end)


local mt = getrawmetatable(game)
local oldNamecall = mt.__namecall
setreadonly(mt, false)




mt.__namecall = newcclosure(function(Self, ...)
    local args = {...}
    local methodName = getnamecallmethod()

    if TargetAim.Enabled then
        if not checkcaller() and methodName == "FireServer" then
            for i, Argument in ipairs(args) do
                if typeof(Argument) == "Vector3" and target and target.Character then
                    local targetPart = target.Character[TargetAim.TargetPart]
                    if targetPart then
                        local adjustedPosition = targetPart.Position + (targetPart.Velocity * TargetAim.Prediction)
                        
                        local jumpOffset = imkhen.JumpOffset or TargetAim.JumpOffset or 0.04
                        if math.abs(targetPart.Velocity.Y) < 3 then
                            adjustedPosition = Vector3.new(adjustedPosition.X, adjustedPosition.Y + jumpOffset, adjustedPosition.Z)
                        end
                        
                        args[i] = adjustedPosition
                        return oldNamecall(Self, unpack(args))
                    end
                end
            end
        end
    end

    return oldNamecall(Self, ...)
end)

setreadonly(mt, true)



local Stats = game:GetService("Stats")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local Network = Stats.Network

local Ping_Based = {
    [0] = 0.1332,
    [10] = 0.1234555,
    [20] = 0.12435,
    [30] = 0.124123,
    [40] = 0.12766,
    [50] = 0.128643,
    [60] = 0.1264236,
    [70] = 0.12533,
    [80] = 0.1321042,
    [90] = 0.1421951,
    [100] = 0.134143,
    [105] = 0.141199,
    [110] = 0.142199,
    [125] = 0.15465,
    [130] = 0.12399,
    [135] = 0.1659921,
    [140] = 0.1659921,
    [145] = 0.129934,
    [150] = 0.1652131,
    [155] = 0.125333,
    [160] = 0.1223333,
    [165] = 0.1652131,
    [170] = 0.16863,
    [175] = 0.16312,
    [180] = 0.1632,
    [185] = 0.16823,
    [190] = 0.18659,
    [205] = 0.17782,
    [215] = 0.16937,
    [225] = 0.176332,
}

local Advanced = {
    [50] = 0.12758545757236864,
    [60] = 0.12593338424986178,
    [70] = 0.1416310605747206,
    [80] = 0.1441481061236737,
    [90] = 0.14306050263254388,
    [100] = 0.14698413210558095,
    [110] = 0.14528324362031425,
    [120] = 0.14556534594403,
    [130] = 0.14614337395777216,
    [140] = 0.14645503036905414,
    [150] = 0.14736848095666674,
    [160] = 0.14696985547996216,
    [170] = 0.14718530231216217,
    [180] = 0.1471532933015037,
    [190] = 0.1471212842908452,
    [200] = 0.14708927528018672,
    [210] = 0.14705726626952823,
    [220] = 0.14702525725886974,
    [230] = 0.14699324824821125,
    [240] = 0.14696123923755276,
    [250] = 0.14692923022689427,
    [260] = 0.14689722121623578,
    [270] = 0.1468652122055773,
    [280] = 0.1468332031949188,
    [290] = 0.1468011941842603,
    [300] = 0.1467691851736018,
}

local Math = {
    [20] = 0.08960952,
    [30] = 0.11252476,
    [50] = 0.13544,
    [65] = 0.1264236,
    [70] = 0.12533,
    [80] = 0.139340,
    [100] = 0.141987,
    [110] = 0.144634,
    [120] = 0.147281,
    [130] = 0.149928,
    [140] = 0.152575,
    [150] = 0.155222,
    [160] = 0.157869,
    [170] = 0.160516,
    [180] = 0.163163,
    [190] = 0.165810,
    [200] = 0.168457,
    [210] = 0.171104,
    [220] = 0.173751,
    [230] = 0.176398,
    [240] = 0.179045,
    [250] = 0.181692,
    [260] = 0.184339,
    [270] = 0.186986,
    [280] = 0.189633,
    [290] = 0.192280,
    [300] = 0.194927,
}

local function updatePredictionValue()
    local pingValue = Network.ServerStatsItem["Data Ping"]:GetValueString()
    local split = string.split(pingValue, '(')
    local ping = tonumber(split[1])

    if ping then
        if getgenv().imkhen.AutoPredMode == "Ping Based" then
            for threshold, value in pairs(Ping_Based) do
                if ping < threshold then
                    getgenv().imkhen.Prediction = value
                    getgenv().TargetAim.Prediction = value
                    getgenv().Silent.Prediction = value
                    break
                end
            end
        end

        if getgenv().imkhen.AutoPredMode == "Advanced" then
            for threshold, value in pairs(Advanced) do
                if ping < threshold then
                    getgenv().imkhen.Prediction = value
                    getgenv().TargetAim.Prediction = value
                    getgenv().Silent.Prediction = value
                    break
                end
            end
        end

        if getgenv().imkhen.AutoPredMode == "Math" then
            for threshold, value in pairs(Math) do
                if ping < threshold then
                    getgenv().imkhen.Prediction = value
                    break
                end
            end
        end
    end
end

while task.wait() do
    if imkhen.Enabled and imkhen.AutoPrediction then
        local pingValue = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
        local ping = tonumber((pingValue:match("%d+")))

        if ping then
            if ping > 225 then
                imkhen.Prediction = 0.22733333333333333
                TargetAim.Prediction = 0.22733333333333333
            elseif ping > 210 then
                imkhen.Prediction = 0.14702525725886974
                TargetAim.Prediction = 0.14702525725886974
            elseif ping > 200 then
                imkhen.Prediction = 0.21966833333333335
                TargetAim.Prediction = 0.21966833333333335
            elseif ping > 190 then
                imkhen.Prediction = 0.1471212842908452
                TargetAim.Prediction = 0.1471212842908452
            elseif ping > 185 then
                imkhen.Prediction = 0.1471532933015037
                TargetAim.Prediction = 0.1471532933015037
            elseif ping > 175 then
                imkhen.Prediction = 0.165455312399999
                TargetAim.Prediction = 0.165455312399999
            elseif ping > 170 then
                imkhen.Prediction = 0.20474833333333334
                TargetAim.Prediction = 0.20474833333333334
            elseif ping > 165 then
                imkhen.Prediction = 0.14696985547996216
                TargetAim.Prediction = 0.14696985547996216
            elseif ping > 155 then
                imkhen.Prediction = 0.14736848095666674
                TargetAim.Prediction = 0.14736848095666674
            elseif ping > 150 then
                imkhen.Prediction = 0.18339333333333335
                TargetAim.Prediction = 0.18339333333333335
            elseif ping > 145 then
                imkhen.Prediction = 0.17654833333333333
                TargetAim.Prediction = 0.17654833333333333
            elseif ping > 140 then
                imkhen.Prediction = 0.17654833333333333
                TargetAim.Prediction = 0.17654833333333333
            elseif ping > 135 then
                imkhen.Prediction = 0.14614337395777216
                TargetAim.Prediction = 0.14614337395777216
            elseif ping > 130 then
                imkhen.Prediction = 0.14614337395777216
                TargetAim.Prediction = 0.14614337395777216
            elseif ping > 125 then
                imkhen.Prediction = 0.16326833333333332
                TargetAim.Prediction = 0.16326833333333332
            elseif ping > 110 then
                imkhen.Prediction = 0.15683333333333335
                TargetAim.Prediction = 0.15683333333333335
            elseif ping > 105 then
                imkhen.Prediction = 0.14698413210558095
                TargetAim.Prediction = 0.14698413210558095
            elseif ping > 100 then
                imkhen.Prediction = 0.15053500000000003
                TargetAim.Prediction = 0.15053500000000003
            elseif ping > 90 then
                imkhen.Prediction = 0.14437333333333335
                TargetAim.Prediction = 0.14437333333333335
            elseif ping > 80 then
                imkhen.Prediction = 0.13834833333333335
                TargetAim.Prediction = 0.13834833333333335
            elseif ping > 70 then
                imkhen.Prediction = 0.1416310605747206
                TargetAim.Prediction = 0.1416310605747206
            elseif ping > 60 then
                imkhen.Prediction = 0.12593338424986178
                TargetAim.Prediction = 0.12593338424986178
            elseif ping > 50 then
                imkhen.Prediction = 0.12758545757236864
                TargetAim.Prediction = 0.12758545757236864
            elseif ping > 40 then
                imkhen.Prediction = 0.11561500000000001
                TargetAim.Prediction = 0.11561500000000001
            elseif ping > 30 then
                imkhen.Prediction = 0.11027333333333333
                TargetAim.Prediction = 0.11027333333333333
            end
        end
    end
end

print("IM KHEN")
